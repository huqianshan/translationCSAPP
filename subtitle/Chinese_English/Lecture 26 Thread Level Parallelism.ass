[Script Info]
; Script generated by Aegisub r8942
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: ../../../../Desktop/csapp/Lecture 26 Thread Level Parallelism.mp4
Video File: ../../../../Desktop/csapp/Lecture 26 Thread Level Parallelism.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 1.000000
Scroll Position: 785
Active Line: 794
Video Position: 117614

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: English,Source Han Sans CN,30,&H00FFFFFF,&H00412A2C,&H00412A2C,&H00412A2C,0,0,0,0,100,100,0,0,1,2.2,1,2,10,10,10,1
Style: Chinese,Source Han Sans CN,34,&H00FBFD00,&H00FFFFFF,&H00362A28,&H00FFFFFF,0,0,0,0,100,100,0,0,1,2,0.2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:01.12,English,,0,0,0,,Hello everyone
Dialogue: 0,0:00:00.00,0:00:01.12,Chinese,,0,0,0,,大家好
Dialogue: 0,0:00:03.78,0:00:08.28,English,,0,0,0,,Interesting,how far fewer seats are filled than at the beginning of the course
Dialogue: 0,0:00:03.78,0:00:08.28,Chinese,,0,0,0,,有趣的是，来的同学比课程刚开始时少很多
Dialogue: 0,0:00:09.70,0:00:14.56,English,,0,0,0,,So that of course we're in the final stretch of this course
Dialogue: 0,0:00:09.70,0:00:14.56,Chinese,,0,0,0,,显然，我们已经到了课程的最后阶段
Dialogue: 0,0:00:15.14,0:00:16.72,English,,0,0,0,,You're working on the last lab
Dialogue: 0,0:00:15.14,0:00:16.72,Chinese,,0,0,0,,你正在做最后一个Lab
Dialogue: 0,0:00:17.44,0:00:23.58,English,,0,0,0,,And the material that we're covering both this lecture and next lecture are not on the exam
Dialogue: 0,0:00:17.44,0:00:23.58,Chinese,,0,0,0,,本次讲座和下一次讲座中所涉及的资料都不在考试中
Dialogue: 0,0:00:23.58,0:00:25.02,English,,0,0,0,,And you don't need them for your lab
Dialogue: 0,0:00:23.58,0:00:25.02,Chinese,,0,0,0,,而且你正在做的Lab也不需要这些内容
Dialogue: 0,0:00:25.02,0:00:28.38,English,,0,0,0,,So at some level you could just to know and skip it all
Dialogue: 0,0:00:25.02,0:00:28.38,Chinese,,0,0,0,,所以在某种程度上你可以跳过本讲内容
Dialogue: 0,0:00:28.38,0:00:31.40,English,,0,0,0,,And if your only purpose in taking this course is to pass it
Dialogue: 0,0:00:28.38,0:00:31.40,Chinese,,0,0,0,,如果你参加这门课程的目的仅仅是通过考试的话
Dialogue: 0,0:00:33.14,0:00:37.52,English,,0,0,0,,Or to get some grade in it and that's it well go ahead to now
Dialogue: 0,0:00:33.14,0:00:37.52,Chinese,,0,0,0,,或者仅仅为了刷学分，那你现在可以离开了。
Dialogue: 0,0:00:38.16,0:00:44.90,English,,0,0,0,,But on the other hand the material we're talking about is very relevant to where computers are today
Dialogue: 0,0:00:38.16,0:00:44.90,Chinese,,0,0,0,,但另一方面，我们今天要讨论的内容，与现阶段的计算机
Dialogue: 0,0:00:44.90,0:00:46.38,English,,0,0,0,,And where they're going in the future
Dialogue: 0,0:00:44.90,0:00:46.38,Chinese,,0,0,0,,以及未来计算机的发展状态，都息息相关。
Dialogue: 0,0:00:46.88,0:00:49.28,English,,0,0,0,,And so if you think about the longer term
Dialogue: 0,0:00:46.88,0:00:49.28,Chinese,,0,0,0,,所以，如果从长远角度考虑
Dialogue: 0,0:00:49.28,0:00:54.02,English,,0,0,0,,And whatever your investment is in the computer industry and computer technology is
Dialogue: 0,0:00:49.28,0:00:54.02,Chinese,,0,0,0,,无论你想投身到计算机工业界或学术界
Dialogue: 0,0:00:54.54,0:00:56.86,English,,0,0,0,,Then I think you'll find these very worthwhile
Dialogue: 0,0:00:54.54,0:00:56.86,Chinese,,0,0,0,,我认为你会发现这些内容都非常有意义。
Dialogue: 0,0:00:57.48,0:01:01.36,English,,0,0,0,,But so think of this more as the icing on the cake
Dialogue: 0,0:00:57.48,0:01:01.36,Chinese,,0,0,0,,所以可以认为这些内容更多是锦上添花
Dialogue: 0,0:01:01.40,0:01:05.28,English,,0,0,0,,You've learned the hard stuff you've done the grinding part
Dialogue: 0,0:01:01.40,0:01:05.28,Chinese,,0,0,0,,你已经学习了困难的部分
Dialogue: 0,0:01:05.70,0:01:12.44,English,,0,0,0,,And now you get to think beyond the sort of narrow confines of the course material and think bigger
Dialogue: 0,0:01:05.70,0:01:12.44,Chinese,,0,0,0,,现在，你可以不局限于课本的内容，进行更广阔的思考。
Dialogue: 0,0:01:12.50,0:01:18.00,English,,0,0,0,,But that's really the way you should be viewing this lecture and the last lecture which will be on Thursday
Dialogue: 0,0:01:12.50,0:01:18.00,Chinese,,0,0,0,,这是你学习本次课和下周最后一次课的视角。
Dialogue: 0,0:01:18.68,0:01:21.30,English,,0,0,0,,So today what we're going to talk about is parallelism
Dialogue: 0,0:01:18.68,0:01:21.30,Chinese,,0,0,0,,所以今天我们要讨论的是并行性
Dialogue: 0,0:01:22.98,0:01:24.20,English,,0,0,0,,And the issue is that...
Dialogue: 0,0:01:22.98,0:01:24.20,Chinese,,0,0,0,,问题是......
Dialogue: 0,0:01:25.98,0:01:26.86,English,,0,0,0,,That
Dialogue: 0,0:01:25.98,0:01:26.86,Chinese,,0,0,0,,是
Dialogue: 0,0:01:28.12,0:01:28.54,English,,0,0,0,,Wow
Dialogue: 0,0:01:28.12,0:01:28.54,Chinese,,0,0,0,,哇
Dialogue: 0,0:01:33.18,0:01:37.26,English,,0,0,0,,That PowerPoint is a product made by a certain company in Seattle that
Dialogue: 0,0:01:33.18,0:01:37.26,Chinese,,0,0,0,,PowerPoint是由西雅图的某家公司（微软）的产品
Dialogue: 0,0:01:38.08,0:01:40.08,English,,0,0,0,,It's not always reliable but
Dialogue: 0,0:01:38.08,0:01:40.08,Chinese,,0,0,0,,显然它不是很稳定
Dialogue: 0,0:01:41.04,0:01:49.30,English,,0,0,0,,The issue is as you know nowadays when you buy a computer you don't get just one CPU on the processor chip
Dialogue: 0,0:01:41.04,0:01:49.30,Chinese,,0,0,0,,问题是如今你购买的电脑的处理器上不会只有一个CPU
Dialogue: 0,0:01:49.38,0:01:52.42,English,,0,0,0,,You have at least two on a typical laptop
Dialogue: 0,0:01:49.38,0:01:52.42,Chinese,,0,0,0,,一般你的笔记本上就至少有两个
Dialogue: 0,0:01:53.10,0:02:00.50,English,,0,0,0,,Even my phone has two cores in it and as well as four graphic processing units
Dialogue: 0,0:01:53.10,0:02:00.50,Chinese,,0,0,0,,甚至连我的手机都有两个CPU以及四个图形处理单元
Dialogue: 0,0:02:01.34,0:02:07.80,English,,0,0,0,,And a typical the next generation of iPad will be a six core processor
Dialogue: 0,0:02:01.34,0:02:07.80,Chinese,,0,0,0,,而下一代iPad将拥有六核处理器
Dialogue: 0,0:02:07.92,0:02:15.90,English,,0,0,0,,So these have become not just the sort of specialized domain of high machines
Dialogue: 0,0:02:07.92,0:02:15.90,Chinese,,0,0,0,,所以这些（多处理器）不仅仅限于高规格的计算机
Dialogue: 0,0:02:16.00,0:02:18.60,English,,0,0,0,,But actually there all the time
Dialogue: 0,0:02:16.00,0:02:18.60,Chinese,,0,0,0,,也会在日常出现
Dialogue: 0,0:02:19.06,0:02:25.80,English,,0,0,0,,And actually we'll talk some next time why is it that instead of having one fast computer
Dialogue: 0,0:02:19.06,0:02:25.80,Chinese,,0,0,0,,实际上我们下次会谈到为什么不是采用一个极快的单核计算机
Dialogue: 0,0:02:25.80,0:02:31.20,English,,0,0,0,,You get two medium size medium performance processors on a chip or more
Dialogue: 0,0:02:25.80,0:02:31.20,Chinese,,0,0,0,,而是使用两个或多个中等速度的多核处理器
Dialogue: 0,0:02:31.68,0:02:35.60,English,,0,0,0,,And that that's actually a really interesting technology issue that I'll talk about next time
Dialogue: 0,0:02:31.68,0:02:35.60,Chinese,,0,0,0,,这实际上是一个非常有趣的技术问题，我将在下次讨论
Dialogue: 0,0:02:36.18,0:02:39.96,English,,0,0,0,,But it's the way it is,so you can think of it when you write a program
Dialogue: 0,0:02:36.18,0:02:39.96,Chinese,,0,0,0,,但它就是这样的，所以当你写一个程序
Dialogue: 0,0:02:41.92,0:02:44.10,English,,0,0,0,,Ah and it runs as a single thread
Dialogue: 0,0:02:41.92,0:02:44.10,Chinese,,0,0,0,,并且是单线程运行时
Dialogue: 0,0:02:44.50,0:02:50.40,English,,0,0,0,,Then you're basically not making use of the computing resources that you have available to you
Dialogue: 0,0:02:44.50,0:02:50.40,Chinese,,0,0,0,,所以你基本上没有（完全）运用能供你使用的计算资源
Dialogue: 0,0:02:51.10,0:02:56.98,English,,0,0,0,,So the natural thing is well could we make our programs run faster by doing multiple threads
Dialogue: 0,0:02:51.10,0:02:56.98,Chinese,,0,0,0,,因此，可以很自然地通过使用多线程，让程序跑的更快
Dialogue: 0,0:02:57.60,0:02:58.64,English,,0,0,0,,So you've already learned
Dialogue: 0,0:02:57.60,0:02:58.64,Chinese,,0,0,0,,所以你已经知道了
Dialogue: 0,0:02:59.16,0:03:04.52,English,,0,0,0,,Or you're in the process of applying a multi-threaded programming
Dialogue: 0,0:02:59.16,0:03:04.52,Chinese,,0,0,0,,或者说你正在使用多线程编程
Dialogue: 0,0:03:05.00,0:03:06.10,English,,0,0,0,,As a way to
Dialogue: 0,0:03:05.00,0:03:06.10,Chinese,,0,0,0,,作为一种
Dialogue: 0,0:03:09.58,0:03:13.88,English,,0,0,0,,Deal with a concurrency of external events
Dialogue: 0,0:03:09.58,0:03:13.88,Chinese,,0,0,0,,处理外部事件并发性的方式
Dialogue: 0,0:03:14.08,0:03:17.82,English,,0,0,0,,There's multiple clients who want to make use of a server
Dialogue: 0,0:03:14.08,0:03:17.82,Chinese,,0,0,0,,有多个客户想要使用服务器
Dialogue: 0,0:03:18.24,0:03:22.32,English,,0,0,0,,And instead of serving one and then another and then another if you can handle them all
Dialogue: 0,0:03:18.24,0:03:22.32,Chinese,,0,0,0,,你可以同时处理他们的请求，而不是挨个处理。
Dialogue: 0,0:03:23.00,0:03:25.80,English,,0,0,0,,It's sort of a an external use of concurrency
Dialogue: 0,0:03:23.00,0:03:25.80,Chinese,,0,0,0,,这是某种外部访问的并发性
Dialogue: 0,0:03:26.60,0:03:29.56,English,,0,0,0,,But what we'll talk about today is more internal use
Dialogue: 0,0:03:26.60,0:03:29.56,Chinese,,0,0,0,,但我们今天要讨论的更多是内部请求
Dialogue: 0,0:03:29.82,0:03:37.40,English,,0,0,0,,Can  make use of multiple threads running on multiple cores to make a program run a single program run faster
Dialogue: 0,0:03:29.82,0:03:37.40,Chinese,,0,0,0,,可以利用在多个内核上运行的多个线程，使运行单个程序更快
Dialogue: 0,0:03:38.16,0:03:41.14,English,,0,0,0,,And the message behind that is yes but
Dialogue: 0,0:03:38.16,0:03:41.14,Chinese,,0,0,0,,其背后的含义是肯定但有条件的。
Dialogue: 0,0:03:41.86,0:03:50.02,English,,0,0,0,,And what mean is it is truly possible and people spend a lot of time making programs run faster by using multiple threads
Dialogue: 0,0:03:41.86,0:03:50.02,Chinese,,0,0,0,,人们确实可以通过花大量时间使程序多线程运行，从而变快
Dialogue: 0,0:03:50.50,0:03:53.76,English,,0,0,0,,But it's harder than you'd think it should be and
Dialogue: 0,0:03:50.50,0:03:53.76,Chinese,,0,0,0,,但它比你想象的要难得多
Dialogue: 0,0:03:53.98,0:03:57.92,English,,0,0,0,,It's fraught with as you probably already experienced programming bugs
Dialogue: 0,0:03:53.98,0:03:57.92,Chinese,,0,0,0,,它可能存在着许多的bug
Dialogue: 0,0:03:58.40,0:04:04.04,English,,0,0,0,,But also it's just really darn hard to get the kind of performance out of a multi-core processor
Dialogue: 0,0:03:58.40,0:04:04.04,Chinese,,0,0,0,,但是，从多核处理器中获得这种你想得到的性能提升
Dialogue: 0,0:04:04.06,0:04:06.34,English,,0,0,0,,That you should would think it'd be available
Dialogue: 0,0:04:04.06,0:04:06.34,Chinese,,0,0,0,,真的很难
Dialogue: 0,0:04:06.86,0:04:08.12,English,,0,0,0,,So we'll talk about some of that
Dialogue: 0,0:04:06.86,0:04:08.12,Chinese,,0,0,0,,所以我们将讨论其中的一些内容
Dialogue: 0,0:04:09.48,0:04:12.72,English,,0,0,0,,And then we'll finish it up a little bit understanding of
Dialogue: 0,0:04:09.48,0:04:12.72,Chinese,,0,0,0,,然后我们将对它进行一些了解
Dialogue: 0,0:04:13.28,0:04:20.46,English,,0,0,0,,How when you writing concurrent programs you want to think about the state of memory
Dialogue: 0,0:04:13.28,0:04:20.46,Chinese,,0,0,0,,如何在编写并发程序时考虑内存状态
Dialogue: 0,0:04:20.92,0:04:27.78,English,,0,0,0,,And how that's a challenge for multi-core processors or in fact any concurrent system
Dialogue: 0,0:04:20.92,0:04:27.78,Chinese,,0,0,0,,这对于多核处理器或实际上任何并发系统来说都是一个挑战
Dialogue: 0,0:04:30.58,0:04:37.90,English,,0,0,0,,So there's actually two sources of concurrency on a modern processor multiple cores
Dialogue: 0,0:04:30.58,0:04:37.90,Chinese,,0,0,0,,因此，在现代多核处理器上实际上有两个并发源
Dialogue: 0,0:04:37.96,0:04:43.08,English,,0,0,0,,Which is you have actually a multiple cpus on a single chip
Dialogue: 0,0:04:37.96,0:04:43.08,Chinese,,0,0,0,,你在一块芯片上实际上有多个cpus
Dialogue: 0,0:04:43.54,0:04:45.48,English,,0,0,0,,But there's also something called hyper-threading
Dialogue: 0,0:04:43.54,0:04:45.48,Chinese,,0,0,0,,但也有一种称为超线程的东西
Dialogue: 0,0:04:46.18,0:04:48.54,English,,0,0,0,,Which is in my experience is less useful
Dialogue: 0,0:04:46.18,0:04:48.54,Chinese,,0,0,0,,根据我的经验，这不太有用
Dialogue: 0,0:04:48.98,0:04:50.02,English,,0,0,0,,But let me go through this
Dialogue: 0,0:04:48.98,0:04:50.02,Chinese,,0,0,0,,但让我来看看
Dialogue: 0,0:04:50.50,0:04:56.36,English,,0,0,0,,So this is what a typical modern processor looks like processor chip
Dialogue: 0,0:04:50.50,0:04:56.36,Chinese,,0,0,0,,所以这就是典型的现代处理器芯片看起来的样子
Dialogue: 0,0:04:57.04,0:04:58.96,English,,0,0,0,,Is that there's actually on a single chip
Dialogue: 0,0:04:57.04,0:04:58.96,Chinese,,0,0,0,,那是真的在一块芯片上吗？
Dialogue: 0,0:04:59.66,0:05:03.28,English,,0,0,0,,There's multiple independent CPUs
Dialogue: 0,0:04:59.66,0:05:03.28,Chinese,,0,0,0,,有多个独立的CPU
Dialogue: 0,0:05:04.72,0:05:09.32,English,,0,0,0,,And each of them has some part of the cache hierarchy
Dialogue: 0,0:05:04.72,0:05:09.32,Chinese,,0,0,0,,并且它们每一个都具有缓存结构的一部分
Dialogue: 0,0:05:10.44,0:05:15.28,English,,0,0,0,,Which is private to that particular core
Dialogue: 0,0:05:10.44,0:05:15.28,Chinese,,0,0,0,,这部分缓存是对每个CPU是私有的
Dialogue: 0,0:05:15.94,0:05:20.04,English,,0,0,0,,And then there is another part of the cache hierarchy that's shared across cores
Dialogue: 0,0:05:15.94,0:05:20.04,Chinese,,0,0,0,,然后这部分是共享的缓存结构
Dialogue: 0,0:05:20.60,0:05:23.66,English,,0,0,0,,And then they all have a common interface to main memory
Dialogue: 0,0:05:20.60,0:05:23.66,Chinese,,0,0,0,,然后他们都有一个与主内存的通用接口
Dialogue: 0,0:05:25.28,0:05:28.34,English,,0,0,0,,So if these cores are running and this is what happens a lot is
Dialogue: 0,0:05:25.28,0:05:28.34,Chinese,,0,0,0,,因此，如果这些核心正在运行，那么就会发生很多事情
Dialogue: 0,0:05:28.42,0:05:32.28,English,,0,0,0,,They're running programs that are completely independent have nothing to do with each
Dialogue: 0,0:05:28.42,0:05:32.28,Chinese,,0,0,0,,他们运行各自完全独立，互不相关的程序
Dialogue: 0,0:05:32.78,0:05:36.90,English,,0,0,0,,Other then they more or less just exist and run and they're happy as can be
Dialogue: 0,0:05:32.78,0:05:36.90,Chinese,,0,0,0,,除此之外，他们各自存在和运行着
Dialogue: 0,0:05:36.90,0:05:40.06,English,,0,0,0,,They are caching parts of their own state
Dialogue: 0,0:05:36.90,0:05:40.06,Chinese,,0,0,0,,他们缓存着各自的状态
Dialogue: 0,0:05:40.70,0:05:49.42,English,,0,0,0,,And you know sometimes this cache will get polluted by the junk from other programs in terms of performance
Dialogue: 0,0:05:40.70,0:05:49.42,Chinese,,0,0,0,,而且在性能方面，有时这个缓存会其他程序的垃圾污染
Dialogue: 0,0:05:49.66,0:05:51.74,English,,0,0,0,,But it will matter with functionality
Dialogue: 0,0:05:49.66,0:05:51.74,Chinese,,0,0,0,,但这对功能性也有影响
Dialogue: 0,0:05:52.46,0:05:56.52,English,,0,0,0,,The trick when you're trying to do multi-core programming as a parallel computing thing
Dialogue: 0,0:05:52.46,0:05:56.52,Chinese,,0,0,0,,当你使用多核程序来进行并行计算时，诀窍是
Dialogue: 0,0:05:56.62,0:06:05.30,English,,0,0,0,,Somehow getting all these cores working on parts of different parts of a single problem in a way that
Dialogue: 0,0:05:56.62,0:06:05.30,Chinese,,0,0,0,,通过某种方式，让这些核心处理单个问题的不同部分
Dialogue: 0,0:06:06.52,0:06:09.12,English,,0,0,0,,Makes it so that you get the performance out of it
Dialogue: 0,0:06:06.52,0:06:09.12,Chinese,,0,0,0,,从而获得所需性能
Dialogue: 0,0:06:09.16,0:06:13.72,English,,0,0,0,,They don't spend all their time basically arguing with each other about who has access to what
Dialogue: 0,0:06:09.16,0:06:13.72,Chinese,,0,0,0,,他们并没有把所有的时间花在争论谁可以访问什么
Dialogue: 0,0:06:14.70,0:06:18.70,English,,0,0,0,,And also they're not stepping over each other and messing up each other's state
Dialogue: 0,0:06:14.70,0:06:18.70,Chinese,,0,0,0,,而且他们也没有干扰对方，弄乱对方的状态
Dialogue: 0,0:06:22.22,0:06:28.78,English,,0,0,0,,So hyper threading is a little bit more into the deep works of how a processor operates
Dialogue: 0,0:06:22.22,0:06:28.78,Chinese,,0,0,0,,因此，超线程更多涉及到一些底层工作，如处理器如何运行
Dialogue: 0,0:06:29.46,0:06:35.06,English,,0,0,0,,You'll recall from the lecture on a performance or what's chapter 5 of the book
Dialogue: 0,0:06:29.46,0:06:35.06,Chinese,,0,0,0,,你可以回忆下之前的视频或者查看书的第五章
Dialogue: 0,0:06:35.76,0:06:43.86,English,,0,0,0,,That a modern microprocessor looks absolutely nothing like the model that you get by looking at assembly code instructions
Dialogue: 0,0:06:35.76,0:06:43.86,Chinese,,0,0,0,,现代微处理器看起来绝对不像汇编代码那样
Dialogue: 0,0:06:44.00,0:06:47.20,English,,0,0,0,,The model of assembly code is you execute one instruction
Dialogue: 0,0:06:44.00,0:06:47.20,Chinese,,0,0,0,,汇编代码的模型是执行一条指令
Dialogue: 0,0:06:47.78,0:06:50.65,English,,0,0,0,,Then you execute the next one then you execute the next one
Dialogue: 0,0:06:47.78,0:06:50.65,Chinese,,0,0,0,,然后执行下一个，然后执行下一个
Dialogue: 0,0:06:51.02,0:06:52.86,English,,0,0,0,,Modern processors don't do that at all
Dialogue: 0,0:06:51.02,0:06:52.86,Chinese,,0,0,0,,现代处理器根本不这样做
Dialogue: 0,0:06:53.34,0:06:59.00,English,,0,0,0,,They haven't done it for...well they haven't done it that way for 30 years
Dialogue: 0,0:06:53.34,0:06:59.00,Chinese,,0,0,0,,他们没有这样做......他们30年来没有这样做过
Dialogue: 0,0:06:59.60,0:07:04.06,English,,0,0,0,,And since 1995 so since 20 years
Dialogue: 0,0:06:59.60,0:07:04.06,Chinese,,0,0,0,,自1995年以来，自20年以来
Dialogue: 0,0:07:04.60,0:07:06.60,English,,0,0,0,,They do it in this totally different way
Dialogue: 0,0:07:04.60,0:07:06.60,Chinese,,0,0,0,,他们以完全不同的方式来设计处理器结构
Dialogue: 0,0:07:07.04,0:07:12.28,English,,0,0,0,,Which is sometimes referred to as out of order processing and so just real quickly
Dialogue: 0,0:07:07.04,0:07:12.28,Chinese,,0,0,0,,这有时被称为无序处理
Dialogue: 0,0:07:13.14,0:07:16.36,English,,0,0,0,,The the basic idea is on the processor chip
Dialogue: 0,0:07:13.14,0:07:16.36,Chinese,,0,0,0,,基本思路是在处理器芯片上
Dialogue: 0,0:07:16.36,0:07:20.78,English,,0,0,0,,There's multiple functional units that are capable of doing different types of operation
Dialogue: 0,0:07:16.36,0:07:20.78,Chinese,,0,0,0,,有多个功能单元能够执行不同类型的操作
Dialogue: 0,0:07:21.24,0:07:26.76,English,,0,0,0,,There's ones for integer arithmetic these ones for floating-point arithmetic and so forth
Dialogue: 0,0:07:21.24,0:07:26.76,Chinese,,0,0,0,,有一些用于整数运算，有些用于浮点运算等等
Dialogue: 0,0:07:27.14,0:07:32.76,English,,0,0,0,,And then there's separate blocks that interface to the memory actually to the cache memories
Dialogue: 0,0:07:27.14,0:07:32.76,Chinese,,0,0,0,,然后这些单独的块，它们实际上与高速缓存存储器连接
Dialogue: 0,0:07:33.38,0:07:38.96,English,,0,0,0,,And they're both loading meaning reading from the memory and storing writing out to memory
Dialogue: 0,0:07:33.38,0:07:38.96,Chinese,,0,0,0,,而且它们都是从内存中读取数据并将写入到内存中
Dialogue: 0,0:07:39.76,0:07:43.14,English,,0,0,0,,But these units are sort of operate independently
Dialogue: 0,0:07:39.76,0:07:43.14,Chinese,,0,0,0,,但这些单位块有点像独立运作
Dialogue: 0,0:07:43.60,0:07:50.88,English,,0,0,0,,And what happens is there's a block of logic which is actually enormous with huge block of logic in an x86 processor
Dialogue: 0,0:07:43.60,0:07:50.88,Chinese,,0,0,0,,接下来会发生的是，在x86处理器中存在大量逻辑块，其中存在巨大的逻辑块
Dialogue: 0,0:07:51.44,0:07:54.40,English,,0,0,0,,That reads the instructions out of the instruction stream
Dialogue: 0,0:07:51.44,0:07:54.40,Chinese,,0,0,0,,它从指令流中读取指令
Dialogue: 0,0:07:54.86,0:08:01.16,English,,0,0,0,,Rips them apart into little pieces， keeps track of data dependencies and control dependencies
Dialogue: 0,0:07:54.86,0:08:01.16,Chinese,,0,0,0,,将它们分成小，并可以跟踪数据依赖性和控制依赖性
Dialogue: 0,0:08:01.66,0:08:07.92,English,,0,0,0,,And then schedules all the various operations in your program on these different functional units
Dialogue: 0,0:08:01.66,0:08:07.92,Chinese,,0,0,0,,然后在这些不同的功能单元上，分配程序的各自操作指令
Dialogue: 0,0:08:08.02,0:08:14.70,English,,0,0,0,,So we talked some about that of in the context of how can you write up program that chenguwill sort of maximize
Dialogue: 0,0:08:08.02,0:08:14.70,Chinese,,0,0,0,,所以我们之前就如何编写程序来最大化处理器
Dialogue: 0,0:08:15.78,0:08:21.64,English,,0,0,0,,How much is going on down here by writing your code in a particular ways
Dialogue: 0,0:08:15.78,0:08:21.64,Chinese,,0,0,0,,这一内容讨论过
Dialogue: 0,0:08:22.62,0:08:26.22,English,,0,0,0,,So all this is an introduction to say
Dialogue: 0,0:08:22.62,0:08:26.22,Chinese,,0,0,0,,所以这一切都是介绍说
Dialogue: 0,0:08:26.60,0:08:29.26,English,,0,0,0,,This is how you have to understand what hyper threading is
Dialogue: 0,0:08:26.60,0:08:29.26,Chinese,,0,0,0,,你必须了解超线程是怎样的
Dialogue: 0,0:08:30.82,0:08:35.46,English,,0,0,0,,So in a single execution mode there's basically one instruction decoder
Dialogue: 0,0:08:30.82,0:08:35.46,Chinese,,0,0,0,,因此，在单个执行单元中，基本上都有一个指令解码器
Dialogue: 0,0:08:36.54,0:08:40.76,English,,0,0,0,,And it has its own set of state here its own program counter
Dialogue: 0,0:08:36.54,0:08:40.76,Chinese,,0,0,0,,它有自己的状态集合，有自己的程序计数器
Dialogue: 0,0:08:41.18,0:08:46.76,English,,0,0,0,,Its own queue of operations that it's already decoded and haven't completed yet
Dialogue: 0,0:08:41.18,0:08:46.76,Chinese,,0,0,0,,有自己已经解码但未执行的操作队列
Dialogue: 0,0:08:47.34,0:08:53.84,English,,0,0,0,,It has its own set of registers they're actually not registers like you'd expect， they're highly virtualized registers
Dialogue: 0,0:08:47.34,0:08:53.84,Chinese,,0,0,0,,它有自己的一组寄存器，它们实际上不是你想的那种寄存器，而是一种高度虚拟化的寄存器
Dialogue: 0,0:08:54.52,0:09:01.84,English,,0,0,0,,But all this state is there to help to service the execution of one thread of execution
Dialogue: 0,0:08:54.52,0:09:01.84,Chinese,,0,0,0,,但是所有这些状态都是为了帮助执行程序的某一个线程
Dialogue: 0,0:09:02.82,0:09:05.26,English,,0,0,0,,With hyper threading basically what you do is
Dialogue: 0,0:09:02.82,0:09:05.26,Chinese,,0,0,0,,超线程的基本思想是
Dialogue: 0,0:09:05.82,0:09:12.78,English,,0,0,0,,The idea that is to say 90% of all programs don't really make use of all these functional units
Dialogue: 0,0:09:05.82,0:09:12.78,Chinese,,0,0,0,,90％的程序都没有完全利用所有这些功能单元
Dialogue: 0,0:09:12.94,0:09:16.86,English,,0,0,0,,Especially if you're blocking on a load
Dialogue: 0,0:09:12.94,0:09:16.86,Chinese,,0,0,0,,特别是因为缓存缺失
Dialogue: 0,0:09:16.86,0:09:19.16,English,,0,0,0,,Because there's a miss in a cache
Dialogue: 0,0:09:16.86,0:09:19.16,Chinese,,0,0,0,,而导致负载阻塞时
Dialogue: 0,0:09:19.86,0:09:24.00,English,,0,0,0,,Then all these arithmetic units are sitting there without anything useful work to do
Dialogue: 0,0:09:19.86,0:09:24.00,Chinese,,0,0,0,,所有这些算术单元都处于空闲状态
Dialogue: 0,0:09:25.52,0:09:28.20,English,,0,0,0,,Oh and so why don't we just double up
Dialogue: 0,0:09:25.52,0:09:28.20,Chinese,,0,0,0,,所以我们为什么不加倍
Dialogue: 0,0:09:29.06,0:09:32.46,English,,0,0,0,,Or quadruple upper K times up
Dialogue: 0,0:09:29.06,0:09:32.46,Chinese,,0,0,0,,或者翻K倍
Dialogue: 0,0:09:33.04,0:09:39.54,English,,0,0,0,,The state associated with the decoding and control parts of the program
Dialogue: 0,0:09:33.04,0:09:39.54,Chinese,,0,0,0,,与程序的解码和控制部分相关联的状态区域
Dialogue: 0,0:09:40.12,0:09:42.34,English,,0,0,0,,So that you can have multiple threads running
Dialogue: 0,0:09:40.12,0:09:42.34,Chinese,,0,0,0,,这样你就可以运行多个线程
Dialogue: 0,0:09:43.68,0:09:46.56,English,,0,0,0,,And sharing these functional units among each other
Dialogue: 0,0:09:43.68,0:09:46.56,Chinese,,0,0,0,,并在彼此之间共享这些功能单元
Dialogue: 0,0:09:46.64,0:09:52.32,English,,0,0,0,,So they're operating really independently their states are not intertwined
Dialogue: 0,0:09:46.64,0:09:52.32,Chinese,,0,0,0,,因此，他们真正地独立运行，他们的状态区域不是交织在一起的
Dialogue: 0,0:09:52.90,0:09:59.24,English,,0,0,0,,But they're sort of making more use of the available hardware for performing functions
Dialogue: 0,0:09:52.90,0:09:59.24,Chinese,,0,0,0,,但他们某种程度上能更多的使用可用硬件来执行函数
Dialogue: 0,0:09:59.56,0:10:02.32,English,,0,0,0,,And so that's called hyper threading that's an Intel term
Dialogue: 0,0:09:59.56,0:10:02.32,Chinese,,0,0,0,,因此，这称为超线程，是英特尔术语
Dialogue: 0,0:10:02.90,0:10:06.78,English,,0,0,0,,You also sometimes hear call SMT simultaneous multi-threading
Dialogue: 0,0:10:02.90,0:10:06.78,Chinese,,0,0,0,,有时也被称为SMT-同步多线程
Dialogue: 0,0:10:07.58,0:10:11.46,English,,0,0,0,,And in my experience and we'll see here the numbers
Dialogue: 0,0:10:07.58,0:10:11.46,Chinese,,0,0,0,,根据我的经验，接下来我们将看到数据
Dialogue: 0,0:10:11.98,0:10:13.72,English,,0,0,0,,It doesn't really make that big a difference
Dialogue: 0,0:10:11.98,0:10:13.72,Chinese,,0,0,0,,它并没有发挥很大的作用
Dialogue: 0,0:10:14.00,0:10:19.72,English,,0,0,0,,But it turns out to be in the sort of large picture things
Dialogue: 0,0:10:14.00,0:10:19.72,Chinese,,0,0,0,,但事实证明，这是一种大局观
Dialogue: 0,0:10:20.16,0:10:24.60,English,,0,0,0,,A relatively inexpensive feature for them to throw on to processors and so they do it
Dialogue: 0,0:10:20.16,0:10:24.60,Chinese,,0,0,0,,能往处理器中加入一个相对便宜的特性时，便添加了
Dialogue: 0,0:10:25.28,0:10:32.30,English,,0,0,0,,And so nowadays at least with an x86 processor usually have 2-way hyper-threading in them
Dialogue: 0,0:10:25.28,0:10:32.30,Chinese,,0,0,0,,因此，现在至少使用x86处理器通常有双向超线程
Dialogue: 0,0:10:34.02,0:10:40.64,English,,0,0,0,,So given that if you look at our shark machines which are a little bit old there's sort of 2010 era machine
Dialogue: 0,0:10:34.02,0:10:40.64,Chinese,,0,0,0,,因此，如果你看到鲨鱼机器的配置，那是2010年代的机器
Dialogue: 0,0:10:41.10,0:10:43.92,English,,0,0,0,,But they were high-end machines in their day
Dialogue: 0,0:10:41.10,0:10:43.92,Chinese,,0,0,0,,但他们当时是高端机器
Dialogue: 0,0:10:43.92,0:10:47.20,English,,0,0,0,,And so they still actually are more powerful than
Dialogue: 0,0:10:43.92,0:10:47.20,Chinese,,0,0,0,,所以它们实际上仍比
Dialogue: 0,0:10:47.72,0:10:53.56,English,,0,0,0,,What you'd buy as say a desktop and way more powerful than as a laptop that you'd get today
Dialogue: 0,0:10:47.72,0:10:53.56,Chinese,,0,0,0,,如今你买的台式机或者笔记本更强大
Dialogue: 0,0:10:53.56,0:10:55.54,English,,0,0,0,,So they're actually pretty decent machines
Dialogue: 0,0:10:53.56,0:10:55.54,Chinese,,0,0,0,,所以他们实际上是相当不错的机器
Dialogue: 0,0:10:55.92,0:11:02.00,English,,0,0,0,,And actually we'll talk next time about why computers aren't a lot faster than they were five years ago
Dialogue: 0,0:10:55.92,0:11:02.00,Chinese,,0,0,0,,实际上，我们下次会谈到为什么计算机不比五年前快得多
Dialogue: 0,0:11:02.00,0:11:04.10,English,,0,0,0,,That's actually an interesting technology thing
Dialogue: 0,0:11:02.00,0:11:04.10,Chinese,,0,0,0,,这实际上是一项有趣的技术
Dialogue: 0,0:11:05.18,0:11:12.22,English,,0,0,0,,So they are server class machines so they have multiple cores
Dialogue: 0,0:11:05.18,0:11:12.22,Chinese,,0,0,0,,鲨鱼机器是服务器类机器，有多个内核
Dialogue: 0,0:11:12.80,0:11:23.54,English,,0,0,0,,And they have eight of them which is a lot you can buy ten core machines x86 machines on a single chip
Dialogue: 0,0:11:12.80,0:11:23.54,Chinese,,0,0,0,,他们有八个核心，你可以购买在一个芯片上有十台核心机器的x86机器
Dialogue: 0,0:11:23.60,0:11:25.14,English,,0,0,0,,But I don't think you can get more yet
Dialogue: 0,0:11:23.60,0:11:25.14,Chinese,,0,0,0,,但我觉得你应该买不到比10更多的了
Dialogue: 0,0:11:25.36,0:11:29.16,English,,0,0,0,,So these were fairly advanced machine of their day
Dialogue: 0,0:11:25.36,0:11:29.16,Chinese,,0,0,0,,所以这些都是当时相当先进的机器
Dialogue: 0,0:11:29.16,0:11:31.50,English,,0,0,0,,And they also have two-way hyper threading
Dialogue: 0,0:11:29.16,0:11:31.50,Chinese,,0,0,0,,而且他们也有双向超线程
Dialogue: 0,0:11:32.64,0:11:33.52,English,,0,0,0,,So in theory
Dialogue: 0,0:11:32.64,0:11:33.52,Chinese,,0,0,0,,所以在理论上
Dialogue: 0,0:11:36.96,0:11:40.34,English,,0,0,0,,You should be able to get sixteen independent threads running
Dialogue: 0,0:11:36.96,0:11:40.34,Chinese,,0,0,0,,你应该能够运行16个独立的线程
Dialogue: 0,0:11:40.62,0:11:44.72,English,,0,0,0,,Sort of 16 way parallelism potentially out of a program
Dialogue: 0,0:11:40.62,0:11:44.72,Chinese,,0,0,0,,或者说在一个程序上运行16个并行线程
Dialogue: 0,0:11:44.74,0:11:50.36,English,,0,0,0,,If you can keep everything working and keep bad things from happening
Dialogue: 0,0:11:44.74,0:11:50.36,Chinese,,0,0,0,,如果你能没有出错的正常运行的化
Dialogue: 0,0:11:55.18,0:12:01.94,English,,0,0,0,,So let's give a really trivial application one that should be very simple to make run in parallel
Dialogue: 0,0:11:55.18,0:12:01.94,Chinese,,0,0,0,,接下来我们来看一个能够并行运行的简单程序
Dialogue: 0,0:12:02.42,0:12:07.74,English,,0,0,0,,That says imaginary we want to sum up the numbers between 0 and n-1
Dialogue: 0,0:12:02.42,0:12:07.74,Chinese,,0,0,0,,假设我们要求0到n-1的数字和
Dialogue: 0,0:12:07.74,0:12:12.38,English,,0,0,0,,Which is by the way a really stupid thing to do because there's a very simple closed-form formula for it
Dialogue: 0,0:12:07.74,0:12:12.38,Chinese,,0,0,0,,这是一个非常愚蠢的事情，因为它有一个非常简单的公式可以计算
Dialogue: 0,0:12:13.28,0:12:15.58,English,,0,0,0,,Which is good in the sense it will let us check our work
Dialogue: 0,0:12:13.28,0:12:15.58,Chinese,,0,0,0,,当然这个公式可以用来帮我们检查正确性
Dialogue: 0,0:12:15.76,0:12:18.36,English,,0,0,0,,But it's a completely stupid application
Dialogue: 0,0:12:15.76,0:12:18.36,Chinese,,0,0,0,,但这是一个非常愚蠢的程序
Dialogue: 0,0:12:19.00,0:12:21.02,English,,0,0,0,,But it just shows you this idea
Dialogue: 0,0:12:19.00,0:12:21.02,Chinese,,0,0,0,,只是为了解释并行性的思想
Dialogue: 0,0:12:21.74,0:12:24.44,English,,0,0,0,,And so what we're just going to do is block off
Dialogue: 0,0:12:21.74,0:12:24.44,Chinese,,0,0,0,,所以我们要做的就是分块
Dialogue: 0,0:12:24.98,0:12:31.68,English,,0,0,0,,If we have n way parallelism we're just going to split a range of numbers n ways
Dialogue: 0,0:12:24.98,0:12:31.68,Chinese,,0,0,0,,如果我们有n个并行线路，则我们将这组数分割成n份
Dialogue: 0,0:12:32.58,0:12:37.60,English,,0,0,0,,And just have a single threads sum up one nth of the numbers
Dialogue: 0,0:12:32.58,0:12:37.60,Chinese,,0,0,0,,只需要一个线程对1/n的数求和
Dialogue: 0,0:12:38.20,0:12:43.50,English,,0,0,0,,And then they'll collectively sum together the result in some way or another
Dialogue: 0,0:12:38.20,0:12:43.50,Chinese,,0,0,0,,然后他们将以某种方式将结果加起来
Dialogue: 0,0:12:43.82,0:12:46.42,English,,0,0,0,,So this is about as easy a parallel program as you could imagine
Dialogue: 0,0:12:43.82,0:12:46.42,Chinese,,0,0,0,,所以这就是一个很简单的并行程序
Dialogue: 0,0:12:47.84,0:12:53.54,English,,0,0,0,,So let's do a 1 version which is said well gee understand how to use threads
Dialogue: 0,0:12:47.84,0:12:53.54,Chinese,,0,0,0,,如果我们知道怎样使用线程，信号量，互斥等概念
Dialogue: 0,0:12:54.20,0:12:58.90,English,,0,0,0,,Pthreads and  know about these things called semaphores or mutual exclusion
Dialogue: 0,0:12:54.20,0:12:58.90,Chinese,,0,0,0,,我们可以写出该程序的版本1
Dialogue: 0,0:12:59.42,0:13:04.58,English,,0,0,0,,So what I'll do is just all I'll have one place in memory
Dialogue: 0,0:12:59.42,0:13:04.58,Chinese,,0,0,0,,首先我们在内存中分配一个空间
Dialogue: 0,0:13:04.58,0:13:08.14,English,,0,0,0,,Where I'm collecting the sum over all n values
Dialogue: 0,0:13:04.58,0:13:08.14,Chinese,,0,0,0,,在那里储存来自N个线程的元素和
Dialogue: 0,0:13:08.88,0:13:11.86,English,,0,0,0,,And for a thread to be able to add to that
Dialogue: 0,0:13:08.88,0:13:11.86,Chinese,,0,0,0,,每个线程都能增加它的值
Dialogue: 0,0:13:12.10,0:13:19.28,English,,0,0,0,,If it will lock it it will get a mutual exclusive access to it increment it and then unlock it
Dialogue: 0,0:13:12.10,0:13:19.28,Chinese,,0,0,0,,如果它将锁定它，它将获得互斥的访问权限，然后将其解锁
Dialogue: 0,0:13:19.40,0:13:24.66,English,,0,0,0,,And we'll just let all the threads go helter-skelter locking and unlocking this
Dialogue: 0,0:13:19.40,0:13:24.66,Chinese,,0,0,0,,让所有的线程都进行慌乱地锁定和解锁
Dialogue: 0,0:13:25.72,0:13:27.52,English,,0,0,0,,So the code for that's pretty easy to write it
Dialogue: 0,0:13:25.72,0:13:27.52,Chinese,,0,0,0,,因此这个代码很容易写
Dialogue: 0,0:13:27.86,0:13:36.46,English,,0,0,0,,It's a here's the code of course all threaded code looks a lot messier than you think it should but
Dialogue: 0,0:13:27.86,0:13:36.46,Chinese,,0,0,0,,当然所有线程代码看起来都比你想象的要麻烦得多
Dialogue: 0,0:13:37.12,0:13:39.32,English,,0,0,0,,In the end it's a fairly straightforward code
Dialogue: 0,0:13:37.12,0:13:39.32,Chinese,,0,0,0,,但它看上去仍是一个相当简单的代码
Dialogue: 0,0:13:40.16,0:13:41.32,English,,0,0,0,,So in particular
Dialogue: 0,0:13:40.16,0:13:41.32,Chinese,,0,0,0,,具体来说
Dialogue: 0,0:13:42.96,0:13:44.46,English,,0,0,0,,This is the thread routine is
Dialogue: 0,0:13:42.96,0:13:44.46,Chinese,,0,0,0,,这是线程例程
Dialogue: 0,0:13:46.12,0:13:55.02,English,,0,0,0,,Passing through this weird vargp structure that you do with threads
Dialogue: 0,0:13:46.12,0:13:55.02,Chinese,,0,0,0,,通过这个奇怪的vargp结构
Dialogue: 0,0:13:55.26,0:13:58.20,English,,0,0,0,,The way you pass arguments to a thread routine
Dialogue: 0,0:13:55.26,0:13:58.20,Chinese,,0,0,0,,你将参数传递给线程例程
Dialogue: 0,0:13:58.60,0:14:02.84,English,,0,0,0,,But basically it's figuring out where is the start and end range of the numbers
Dialogue: 0,0:13:58.60,0:14:02.84,Chinese,,0,0,0,,基本上它的作用是弄清楚数字的开始和结束区域
Dialogue: 0,0:14:03.56,0:14:09.52,English,,0,0,0,,Then adding for all i between the start before the end
Dialogue: 0,0:14:03.56,0:14:09.52,Chinese,,0,0,0,,并在这个区间内添加所有的i
Dialogue: 0,0:14:10.10,0:14:14.88,English,,0,0,0,,I'll lock that acquire a semaphore lock
Dialogue: 0,0:14:10.10,0:14:14.88,Chinese,,0,0,0,,我将得到一个信号量锁定
Dialogue: 0,0:14:15.64,0:14:19.08,English,,0,0,0,,I'll increment this global sum and then I'll release the lock
Dialogue: 0,0:14:15.64,0:14:19.08,Chinese,,0,0,0,,然后增加这个全局总和，然后释放锁定
Dialogue: 0,0:14:20.66,0:14:23.56,English,,0,0,0,,Okay so pretty much the style of code that you've been working with
Dialogue: 0,0:14:20.66,0:14:23.56,Chinese,,0,0,0,,这是我们很熟悉的代码风格
Dialogue: 0,0:14:25.10,0:14:27.92,English,,0,0,0,,And what you find is actually this is really a bad idea
Dialogue: 0,0:14:25.10,0:14:27.92,Chinese,,0,0,0,,这其实是个坏主意
Dialogue: 0,0:14:28.92,0:14:30.40,English,,0,0,0,,So running as a single thread
Dialogue: 0,0:14:28.92,0:14:30.40,Chinese,,0,0,0,,如果是单线程运行
Dialogue: 0,0:14:31.22,0:14:33.04,English,,0,0,0,,It takes 51 seconds to do that
Dialogue: 0,0:14:31.22,0:14:33.04,Chinese,,0,0,0,,需要51秒来完成
Dialogue: 0,0:14:33.04,0:14:37.04,English,,0,0,0,,It would be by the way if you didn't lock and unlock because it's only one thread
Dialogue: 0,0:14:33.04,0:14:37.04,Chinese,,0,0,0,,顺便说一句，如果你没有使用锁定和解锁，因为它只是一个线程
Dialogue: 0,0:14:37.04,0:14:40.60,English,,0,0,0,,You'd blow this away it would take just a couple seconds so
Dialogue: 0,0:14:37.04,0:14:40.60,Chinese,,0,0,0,,你会惊讶地发现这仅需要几秒钟
Dialogue: 0,0:14:41.30,0:14:44.02,English,,0,0,0,,And then you see as you add more threads it actually gets worse
Dialogue: 0,0:14:41.30,0:14:44.02,Chinese,,0,0,0,,当添加了更多地线程时，时间会越慢
Dialogue: 0,0:14:44.80,0:14:47.60,English,,0,0,0,,And especially if you jump from one to two
Dialogue: 0,0:14:44.80,0:14:47.60,Chinese,,0,0,0,,特别是如果你一个线程变成两个时
Dialogue: 0,0:14:48.12,0:14:51.32,English,,0,0,0,,You increase by a factor nine how much time  it takes
Dialogue: 0,0:14:48.12,0:14:51.32,Chinese,,0,0,0,,你增加了9倍的时间
Dialogue: 0,0:14:52.78,0:14:58.04,English,,0,0,0,,And it always starts to get better as you get up into eight threads and then it gets worse again
Dialogue: 0,0:14:52.78,0:14:58.04,Chinese,,0,0,0,,当你增加到第八个线程时，耗时会少一点，但继续增加，耗时仍会越来越多
Dialogue: 0,0:14:59.04,0:15:06.28,English,,0,0,0,,So the reason is that locking unlocking is a very time-consuming task
Dialogue: 0,0:14:59.04,0:15:06.28,Chinese,,0,0,0,,因为锁定解锁是一项非常耗时的任务
Dialogue: 0,0:15:06.30,0:15:07.88,English,,0,0,0,,And basically you can think of...
Dialogue: 0,0:15:06.30,0:15:07.88,Chinese,,0,0,0,,你可以这样设想......
Dialogue: 0,0:15:09.90,0:15:15.40,English,,0,0,0,,If you have that map of the multi-core processors with all their private caches in one shared cache
Dialogue: 0,0:15:09.90,0:15:15.40,Chinese,,0,0,0,,如果你有一个多核处理器，所有核地私有缓存都是一块共有的缓存区
Dialogue: 0,0:15:16.10,0:15:22.30,English,,0,0,0,,These threads are basically fighting with each other for control for that one memory address
Dialogue: 0,0:15:16.10,0:15:22.30,Chinese,,0,0,0,,这些线程会去互相争夺这块
Dialogue: 0,0:15:22.48,0:15:25.90,English,,0,0,0,,That they that they're incrementing
Dialogue: 0,0:15:22.48,0:15:25.90,Chinese,,0,0,0,,他们正在增加地址的内存区域
Dialogue: 0,0:15:26.48,0:15:31.14,English,,0,0,0,,And it has to grab the control away from one core to your the core
Dialogue: 0,0:15:26.48,0:15:31.14,Chinese,,0,0,0,,控制权从一个核心抢到了
Dialogue: 0,0:15:31.62,0:15:35.44,English,,0,0,0,,That's accessing it do the lock unlock
Dialogue: 0,0:15:31.62,0:15:35.44,Chinese,,0,0,0,,另一个正在锁定和解锁的核心
Dialogue: 0,0:15:35.98,0:15:39.60,English,,0,0,0,,And then it gets grabbed back for it so it's a miserable performance for cache
Dialogue: 0,0:15:35.98,0:15:39.60,Chinese,,0,0,0,,然后它又被被抢回去，这对于缓存来说是很糟糕的
Dialogue: 0,0:15:40.24,0:15:42.80,English,,0,0,0,,Huge overhead for the semaphore activities
Dialogue: 0,0:15:40.24,0:15:42.80,Chinese,,0,0,0,,信号量活动有巨大的开销
Dialogue: 0,0:15:43.36,0:15:45.42,English,,0,0,0,,And just really a bad thing all around
Dialogue: 0,0:15:43.36,0:15:45.42,Chinese,,0,0,0,,是一件非常糟糕的事
Dialogue: 0,0:15:45.44,0:15:51.31,English,,0,0,0,,And so lesson one is semaphores or mutexes are very expensive
Dialogue: 0,0:15:45.44,0:15:51.31,Chinese,,0,0,0,,这告诉我们信号量或者说互斥量是非常昂贵的
Dialogue: 0,0:15:52.06,0:15:54.90,English,,0,0,0,,And if you're trying to do low level parallelism
Dialogue: 0,0:15:52.06,0:15:54.90,Chinese,,0,0,0,,如果你正在尝试做一些低级的并发处理
Dialogue: 0,0:15:54.90,0:15:58.90,English,,0,0,0,,You don't want fine-grained locking at that level otherwise
Dialogue: 0,0:15:54.90,0:15:58.90,Chinese,,0,0,0,,你不想做一些很细分的锁定和解锁
Dialogue: 0,0:15:59.02,0:16:00.32,English,,0,0,0,,You're just completely sunk
Dialogue: 0,0:15:59.02,0:16:00.32,Chinese,,0,0,0,,不然你的程序很慢
Dialogue: 0,0:16:00.50,0:16:02.92,English,,0,0,0,,And so that's not the way to do it
Dialogue: 0,0:16:00.50,0:16:02.92,Chinese,,0,0,0,,这不是并发的正确使用方式
Dialogue: 0,0:16:03.34,0:16:08.78,English,,0,0,0,,I won't go into it but there's quite a bit of literature about what they call lock free synchronization
Dialogue: 0,0:16:03.34,0:16:08.78,Chinese,,0,0,0,,我不会详细展开，但有很多关于“无锁同步”的文献
Dialogue: 0,0:16:09.24,0:16:12.20,English,,0,0,0,,Which is a way to avoid semaphores but get the effect
Dialogue: 0,0:16:09.24,0:16:12.20,Chinese,,0,0,0,,这是一种避免信号量但获得想要效果的方法
Dialogue: 0,0:16:12.78,0:16:15.00,English,,0,0,0,,And they wouldn't work in this context either those
Dialogue: 0,0:16:12.78,0:16:15.00,Chinese,,0,0,0,,那种方法也不会在我们这种情况下使用
Dialogue: 0,0:16:15.54,0:16:17.36,English,,0,0,0,,Just if you've ever heard that term
Dialogue: 0,0:16:15.54,0:16:17.36,Chinese,,0,0,0,,如果你们听说过那个词
Dialogue: 0,0:16:17.74,0:16:19.54,English,,0,0,0,,Those are generally designed for
Dialogue: 0,0:16:17.74,0:16:19.54,Chinese,,0,0,0,,这些通常是为
Dialogue: 0,0:16:20.30,0:16:25.80,English,,0,0,0,,Examples where you expect relatively little contention between the threads
Dialogue: 0,0:16:20.30,0:16:25.80,Chinese,,0,0,0,,那些进程存在很少的冲突的情况设计
Dialogue: 0,0:16:25.80,0:16:30.30,English,,0,0,0,,And so you try and be optimistic and then roll back if something bad happens
Dialogue: 0,0:16:25.80,0:16:30.30,Chinese,,0,0,0,,所以你假设不会产生冲突，然后如果发生了不好的事情就返回
Dialogue: 0,0:16:31.90,0:16:33.52,English,,0,0,0,,This is a case where nope
Dialogue: 0,0:16:31.90,0:16:33.52,Chinese,,0,0,0,,我们这个案例是
Dialogue: 0,0:16:33.78,0:16:38.24,English,,0,0,0,,All those threads are going to be pounding that one memory location and they're really fighting for it
Dialogue: 0,0:16:33.78,0:16:38.24,Chinese,,0,0,0,,所有这些线程都将冲击一个内存位置，他们真的都在争夺它
Dialogue: 0,0:16:38.30,0:16:41.10,English,,0,0,0,,And so there is no good solution to that problem
Dialogue: 0,0:16:38.30,0:16:41.10,Chinese,,0,0,0,,所以这个问题没有很好的解决方案
Dialogue: 0,0:16:43.70,0:16:47.48,English,,0,0,0,,The other thing I'll point out is this jump here shows you that
Dialogue: 0,0:16:43.70,0:16:47.48,Chinese,,0,0,0,,我要指出的另一件事就是：从8线程变成16线程告诉了我们
Dialogue: 0,0:16:48.20,0:16:50.76,English,,0,0,0,,Hyper threading isn't really helping us here
Dialogue: 0,0:16:48.20,0:16:50.76,Chinese,,0,0,0,,超线程并不能真正帮助我们
Dialogue: 0,0:16:52.42,0:16:55.88,English,,0,0,0,,Going from the fact that we slowed down from 8 to 16
Dialogue: 0,0:16:52.42,0:16:55.88,Chinese,,0,0,0,,8线程变成16线程，速度更慢
Dialogue: 0,0:16:55.88,0:16:59.16,English,,0,0,0,,Means we can't really make use of 16 threads in this application
Dialogue: 0,0:16:55.88,0:16:59.16,Chinese,,0,0,0,,意味着我们无法在此应用程序中真正使用16个线程
Dialogue: 0,0:16:59.68,0:17:01.60,English,,0,0,0,,8 threads are better than 4
Dialogue: 0,0:16:59.68,0:17:01.60,Chinese,,0,0,0,,8个线程比4个好
Dialogue: 0,0:17:02.06,0:17:06.74,English,,0,0,0,,But obviously all that's kind of a waste of time because this is just really a bad idea all around
Dialogue: 0,0:17:02.06,0:17:06.74,Chinese,,0,0,0,,但显然所有这些都浪费时间，因为线程这样设计本身是个很糟糕的主意
Dialogue: 0,0:17:08.38,0:17:08.72,English,,0,0,0,,So
Dialogue: 0,0:17:08.38,0:17:08.72,Chinese,,0,0,0,,所以
Dialogue: 0,0:17:09.56,0:17:11.14,English,,0,0,0,,Let's do something different
Dialogue: 0,0:17:09.56,0:17:11.14,Chinese,,0,0,0,,让我们来尝试另一种方法
Dialogue: 0,0:17:11.18,0:17:17.06,English,,0,0,0,,Let's have each of them accumulate their own sum for their own sub range
Dialogue: 0,0:17:11.18,0:17:17.06,Chinese,,0,0,0,,让所有的线程在它们的子范围内累加自己的和
Dialogue: 0,0:17:18.60,0:17:22.16,English,,0,0,0,,And we'll give up so we'll have an array of accumulators
Dialogue: 0,0:17:18.60,0:17:22.16,Chinese,,0,0,0,,所以我们将一个累加器数组
Dialogue: 0,0:17:23.12,0:17:29.72,English,,0,0,0,,Where the each thread is incrementing only a one element of this array
Dialogue: 0,0:17:23.12,0:17:29.72,Chinese,,0,0,0,,每个线程只增加此数组的一个元素
Dialogue: 0,0:17:30.56,0:17:33.38,English,,0,0,0,,So they're not fighting with each other directly for it
Dialogue: 0,0:17:30.56,0:17:33.38,Chinese,,0,0,0,,所以他们不是直接在相互争斗数组的使用权
Dialogue: 0,0:17:33.58,0:17:38.96,English,,0,0,0,,But they are fighting for if you think about it for the same cache line
Dialogue: 0,0:17:33.58,0:17:38.96,Chinese,,0,0,0,,但是它们仍然在争夺这个缓存
Dialogue: 0,0:17:39.84,0:17:43.92,English,,0,0,0,,Because an array is typically stored and so it's not totally nice
Dialogue: 0,0:17:39.84,0:17:43.92,Chinese,,0,0,0,,因为数组通常是存储的存储的，所有它不是很好
Dialogue: 0,0:17:45.70,0:17:48.68,English,,0,0,0,,Ah but this it gives you a pointer to this idea
Dialogue: 0,0:17:45.70,0:17:48.68,Chinese,,0,0,0,,但这我们提供了一个思路
Dialogue: 0,0:17:48.80,0:17:52.14,English,,0,0,0,,If we could sort of move into a private state
Dialogue: 0,0:17:48.80,0:17:52.14,Chinese,,0,0,0,,如果我们可以进入私有状态
Dialogue: 0,0:17:52.88,0:17:55.86,English,,0,0,0,,The stuff that we're making the most direct access to
Dialogue: 0,0:17:52.88,0:17:55.86,Chinese,,0,0,0,,我们能够直接访问的东西
Dialogue: 0,0:17:56.68,0:17:58.40,English,,0,0,0,,Then we'll get better performance
Dialogue: 0,0:17:56.68,0:17:58.40,Chinese,,0,0,0,,我们会获得更好的表现
Dialogue: 0,0:17:59.68,0:18:01.44,English,,0,0,0,,So this is the thread routine
Dialogue: 0,0:17:59.68,0:18:01.44,Chinese,,0,0,0,,所以这是我们的线程例程
Dialogue: 0,0:18:01.96,0:18:05.12,English,,0,0,0,,And that the point is that there's some global array called psum
Dialogue: 0,0:18:01.96,0:18:05.12,Chinese,,0,0,0,,该程序的关键是有叫做psum的全局数组
Dialogue: 0,0:18:05.12,0:18:10.80,English,,0,0,0,,But it's only incrementing the part of it that sort of assigned to this particular thread
Dialogue: 0,0:18:05.12,0:18:10.80,Chinese,,0,0,0,,它只增加分配给某一特定线程的数组元素
Dialogue: 0,0:18:12.92,0:18:15.44,English,,0,0,0,,And here you do see a performance improvement right
Dialogue: 0,0:18:12.92,0:18:15.44,Chinese,,0,0,0,,在这里，你确实看到了正确的性能提升
Dialogue: 0,0:18:15.56,0:18:19.78,English,,0,0,0,,So one thread takes 5 seconds remember before it was 58
Dialogue: 0,0:18:15.56,0:18:19.78,Chinese,,0,0,0,,所以一个线程需要5秒而不是之前的58秒
Dialogue: 0,0:18:19.92,0:18:25.16,English,,0,0,0,,So that shows you just the advantage of the cost of semaphores
Dialogue: 0,0:18:19.92,0:18:25.16,Chinese,,0,0,0,,这样就向你展示了信号量成本的优势
Dialogue: 0,0:18:25.66,0:18:27.14,English,,0,0,0,,Right there is a factor of 10
Dialogue: 0,0:18:25.66,0:18:27.14,Chinese,,0,0,0,,对，有10倍
Dialogue: 0,0:18:27.74,0:18:33.12,English,,0,0,0,,And you see you are actually getting an improvement all across the line including up to 16 threads
Dialogue: 0,0:18:27.74,0:18:33.12,Chinese,,0,0,0,,观察整个线条，你会发现所有的情况都有改善，包括16线程的情况
Dialogue: 0,0:18:33.14,0:18:34.50,English,,0,0,0,,You're still getting an improvement
Dialogue: 0,0:18:33.14,0:18:34.50,Chinese,,0,0,0,,你还在改进
Dialogue: 0,0:18:35.02,0:18:38.14,English,,0,0,0,,It would flatten out should have just shown the number for 32
Dialogue: 0,0:18:35.02,0:18:38.14,Chinese,,0,0,0,,这里会变扁平（如果我展示32线程的情况）
Dialogue: 0,0:18:38.14,0:18:40.02,English,,0,0,0,,But it would flatten out at this point
Dialogue: 0,0:18:38.14,0:18:40.02,Chinese,,0,0,0,,线条会在之后变得扁平
Dialogue: 0,0:18:40.56,0:18:43.78,English,,0,0,0,,But it actually is getting some advantage out of hyper-threading as well
Dialogue: 0,0:18:40.56,0:18:43.78,Chinese,,0,0,0,,但它实际上也从超线程中获得了一些增速
Dialogue: 0,0:18:45.34,0:18:48.14,English,,0,0,0,,So that's good it's not an amazing speed up
Dialogue: 0,0:18:45.34,0:18:48.14,Chinese,,0,0,0,,这很好，但这也不是一个惊人的加速
Dialogue: 0,0:18:48.46,0:18:57.48,English,,0,0,0,,So you can think of what they call the speed up is the performance of it running on a single core versus the performance on n cores
Dialogue: 0,0:18:48.46,0:18:57.48,Chinese,,0,0,0,,所以你可以想到他们所谓的加速是它在单核上运行的性能与n核上的性能相比
Dialogue: 0,0:18:57.48,0:19:00.30,English,,0,0,0,,And in the ideal case it goes n times faster
Dialogue: 0,0:18:57.48,0:19:00.30,Chinese,,0,0,0,,在理想情况下，它的速度提高了n倍
Dialogue: 0,0:19:00.94,0:19:02.28,English,,0,0,0,,And we're not quite hitting that
Dialogue: 0,0:19:00.94,0:19:02.28,Chinese,,0,0,0,,我们并没有达到那种性能
Dialogue: 0,0:19:05.90,0:19:12.04,English,,0,0,0,,Well but here's if you've already learned that it's generally bad to be accumulating into a memory
Dialogue: 0,0:19:05.90,0:19:12.04,Chinese,,0,0,0,,但如果你知道了，直接在共享内存中累加是不好的
Dialogue: 0,0:19:12.58,0:19:15.50,English,,0,0,0,,And so why not do the thing we learned before
Dialogue: 0,0:19:12.58,0:19:15.50,Chinese,,0,0,0,,那么为什么试一下我们之前学到的东西呢
Dialogue: 0,0:19:15.90,0:19:20.50,English,,0,0,0,,Which is you accumulate in a register and you only update the memory when you're done with that
Dialogue: 0,0:19:15.90,0:19:20.50,Chinese,,0,0,0,,现在寄存器内累加，再将结果更新好内存中
Dialogue: 0,0:19:21.30,0:19:24.76,English,,0,0,0,,So let's just do that and I'll call that the local version
Dialogue: 0,0:19:21.30,0:19:24.76,Chinese,,0,0,0,,所以，让我们这样做，我会称之为本地版本
Dialogue: 0,0:19:25.20,0:19:28.60,English,,0,0,0,,I'll just increment a sum which is a local variable
Dialogue: 0,0:19:25.20,0:19:28.60,Chinese,,0,0,0,,我将增加一个本地变量sum
Dialogue: 0,0:19:29.06,0:19:30.46,English,,0,0,0,,And only when I'm done
Dialogue: 0,0:19:29.06,0:19:30.46,Chinese,,0,0,0,,只有当我完成了
Dialogue: 0,0:19:31.24,0:19:35.30,English,,0,0,0,,Then I'll store it in the global array
Dialogue: 0,0:19:31.24,0:19:35.30,Chinese,,0,0,0,,我把它它存储在全局数组中
Dialogue: 0,0:19:37.14,0:19:40.52,English,,0,0,0,,Okay so it's functionally equivalent to the one we just showed
Dialogue: 0,0:19:37.14,0:19:40.52,Chinese,,0,0,0,,好的，它在功能上等同于我们刚刚展示的那个
Dialogue: 0,0:19:40.52,0:19:46.18,English,,0,0,0,,We're just moving instead of accumulating in a global array we're accumulating in a register
Dialogue: 0,0:19:40.52,0:19:46.18,Chinese,,0,0,0,,我们仅仅把现在寄存器中累加和移动到全局数组中
Dialogue: 0,0:19:47.30,0:19:49.92,English,,0,0,0,,And here you see a pretty big performance improvement
Dialogue: 0,0:19:47.30,0:19:49.92,Chinese,,0,0,0,,这样，你可以看到相当大的性能提升
Dialogue: 0,0:19:51.18,0:20:00.04,English,,0,0,0,,So blue is what we showed with the global array,red or orange is what's this local variable
Dialogue: 0,0:19:51.18,0:20:00.04,Chinese,,0,0,0,,所以蓝色是我们用全局数组的，红色或橙色是局部变量
Dialogue: 0,0:20:00.76,0:20:04.56,English,,0,0,0,,And so you see it's actually interesting we're getting a performance improvement
Dialogue: 0,0:20:00.76,0:20:04.56,Chinese,,0,0,0,,你会看到我们得到了很有趣的性能提升
Dialogue: 0,0:20:05.38,0:20:11.12,English,,0,0,0,,As well although it bottoms out at eight
Dialogue: 0,0:20:05.38,0:20:11.12,Chinese,,0,0,0,,尽管它在8线程达到最低点
Dialogue: 0,0:20:11.28,0:20:13.89,English,,0,0,0,,And it actually gets worse when you go to sixteen
Dialogue: 0,0:20:11.28,0:20:13.89,Chinese,,0,0,0,,在16线程时，它实际上会变得更糟
Dialogue: 0,0:20:14.44,0:20:17.24,English,,0,0,0,,And this is showing that hyper-threading isn't really helping here
Dialogue: 0,0:20:14.44,0:20:17.24,Chinese,,0,0,0,,这表明超线程在这方面并没有真正帮助
Dialogue: 0,0:20:17.24,0:20:21.98,English,,0,0,0,,Because basically the single thread is just accumulating
Dialogue: 0,0:20:17.24,0:20:21.98,Chinese,,0,0,0,,因为基本上，单线程只是在累加
Dialogue: 0,0:20:22.68,0:20:27.22,English,,0,0,0,,As fast as it can and adding to a register
Dialogue: 0,0:20:22.68,0:20:27.22,Chinese,,0,0,0,,尽可能快地把数加到寄存器上
Dialogue: 0,0:20:27.64,0:20:32.54,English,,0,0,0,,And so it's making pretty good use of what functional units it uses and putting multiple threads
Dialogue: 0,0:20:27.64,0:20:32.54,Chinese,,0,0,0,,因此，它正在很好地利用它使用的功能单元并放置多个线程
Dialogue: 0,0:20:33.02,0:20:34.50,English,,0,0,0,,Sharing it isn't really helping
Dialogue: 0,0:20:33.02,0:20:34.50,Chinese,,0,0,0,,分享它并没有真正帮助
Dialogue: 0,0:20:34.96,0:20:39.30,English,,0,0,0,,At least not on the shark machines
Dialogue: 0,0:20:34.96,0:20:39.30,Chinese,,0,0,0,,至少不在鲨鱼机上
Dialogue: 0,0:20:39.48,0:20:42.24,English,,0,0,0,,This actually might be different on different machines
Dialogue: 0,0:20:39.48,0:20:42.24,Chinese,,0,0,0,,这实际上可能在不同的机器上有所不同
Dialogue: 0,0:20:43.48,0:20:49.34,English,,0,0,0,,And actually if you recall from the performance optimization we found that if you're just doing a bunch of additions
Dialogue: 0,0:20:43.48,0:20:49.34,Chinese,,0,0,0,,实际上，如果你从性能优化中回忆起来，我们发现如果你只是做了很多补充
Dialogue: 0,0:20:49.96,0:20:54.36,English,,0,0,0,,You can make use as associativity and get more accumulation in parallel
Dialogue: 0,0:20:49.96,0:20:54.36,Chinese,,0,0,0,,你可以将其用作关联性并获得更多并行累积
Dialogue: 0,0:20:54.86,0:20:59.66,English,,0,0,0,,So you could actually speed up this program just the single threaded version of this program pretty well
Dialogue: 0,0:20:54.86,0:20:59.66,Chinese,,0,0,0,,所以你实际上可以加速这个程序只是这个程序的单线程版本
Dialogue: 0,0:21:00.24,0:21:04.66,English,,0,0,0,,But anyways it shows it okay this is starting to look like
Dialogue: 0,0:21:00.24,0:21:04.66,Chinese,,0,0,0,,但无论如何它表明它可以开始看起来像
Dialogue: 0,0:21:05.14,0:21:09.76,English,,0,0,0,,Your a your single threaded performance is pretty good and b
Dialogue: 0,0:21:05.14,0:21:09.76,Chinese,,0,0,0,,你的单线程性能非常好b
Dialogue: 0,0:21:10.08,0:21:13.44,English,,0,0,0,,You're getting some useful speed-up out of parallelism
Dialogue: 0,0:21:10.08,0:21:13.44,Chinese,,0,0,0,,你可以从并行性中获得一些有用的加速
Dialogue: 0,0:21:14.48,0:21:19.36,English,,0,0,0,,But as  said this is like the easiest example in the world to parallelize so if you can't do it here
Dialogue: 0,0:21:14.48,0:21:19.36,Chinese,,0,0,0,,但正如所说的，这就像世界上最简单的并行化示例，如果你不能在这里做到这一点
Dialogue: 0,0:21:19.90,0:21:24.52,English,,0,0,0,,Then life is pretty hopeless as far as multi-threading
Dialogue: 0,0:21:19.90,0:21:24.52,Chinese,,0,0,0,,然后就多线程而言，生活是绝望的
Dialogue: 0,0:21:25.80,0:21:29.70,English,,0,0,0,,So let's talk about as mentioned this idea of speed-up
Dialogue: 0,0:21:25.80,0:21:29.70,Chinese,,0,0,0,,所以让我们谈谈提到加速这个想法
Dialogue: 0,0:21:30.70,0:21:35.14,English,,0,0,0,,So speed-up is just defined to be the time for a single-threaded program
Dialogue: 0,0:21:30.70,0:21:35.14,Chinese,,0,0,0,,因此，加速定义为单线程程序的时间
Dialogue: 0,0:21:35.82,0:21:40.86,English,,0,0,0,,Divided by the time for pthreads running
Dialogue: 0,0:21:35.82,0:21:40.86,Chinese,,0,0,0,,除以pthreads运行的时间
Dialogue: 0,0:21:41.47,0:21:45.66,English,,0,0,0,,Or actually will use it p cores instead of pthreads,question
Dialogue: 0,0:21:41.47,0:21:45.66,Chinese,,0,0,0,,或实际上将使用它p核而不是pthreads，问题
Dialogue: 0,0:21:45.72,0:21:51.64,English,,0,0,0,,[student speaking]
Dialogue: 0,0:21:51.64,0:21:57.72,English,,0,0,0,,Yes generally you know the scheduler has some kind of go balancing built into it
Dialogue: 0,0:21:51.64,0:21:57.72,Chinese,,0,0,0,,是的，通常你知道调度程序有一些内置的平衡
Dialogue: 0,0:21:58.54,0:22:05.14,English,,0,0,0,,And it will tend to especially in a case like this where the threads are sort of grabbing and running
Dialogue: 0,0:21:58.54,0:22:05.14,Chinese,,0,0,0,,特别是在这样的情况下，线程会抓住并运行
Dialogue: 0,0:22:05.72,0:22:10.96,English,,0,0,0,,Making they will generally get spread across the cores
Dialogue: 0,0:22:05.72,0:22:10.96,Chinese,,0,0,0,,使它们通常会遍布核心
Dialogue: 0,0:22:11.92,0:22:14.60,English,,0,0,0,,So that's a pretty the linux scheduler is pretty good at
Dialogue: 0,0:22:11.92,0:22:14.60,Chinese,,0,0,0,,所以这是一个非常好的Linux调度程序非常擅长
Dialogue: 0,0:22:15.24,0:22:19.32,English,,0,0,0,,That when you have more threads than there are cores
Dialogue: 0,0:22:15.24,0:22:19.32,Chinese,,0,0,0,,当你有更多的线程而不是核心
Dialogue: 0,0:22:19.98,0:22:27.56,English,,0,0,0,,Then it basically starts scheduling them in some cyclic order
Dialogue: 0,0:22:19.98,0:22:27.56,Chinese,,0,0,0,,然后它基本上开始以某种循环顺序调度它们
Dialogue: 0,0:22:27.58,0:22:29.84,English,,0,0,0,,And you won't...you'll...
Dialogue: 0,0:22:27.58,0:22:29.84,Chinese,,0,0,0,,你不会......你会......
Dialogue: 0,0:22:30.68,0:22:33.86,English,,0,0,0,,At best you will not get any advantage
Dialogue: 0,0:22:30.68,0:22:33.86,Chinese,,0,0,0,,充其量你不会得到任何好处
Dialogue: 0,0:22:34.00,0:22:39.00,English,,0,0,0,,And in a worst case you actually start slowing down from having more threads than are
Dialogue: 0,0:22:34.00,0:22:39.00,Chinese,,0,0,0,,在最糟糕的情况下，你实际上开始因为拥有更多线程而放慢速度
Dialogue: 0,0:22:39.94,0:22:40.80,English,,0,0,0,,There good question
Dialogue: 0,0:22:39.94,0:22:40.80,Chinese,,0,0,0,,有好问题
Dialogue: 0,0:22:41.24,0:22:43.00,English,,0,0,0,,So there's really two versions of speed-up
Dialogue: 0,0:22:41.24,0:22:43.00,Chinese,,0,0,0,,所以真的有两种版本的加速
Dialogue: 0,0:22:43.02,0:22:48.06,English,,0,0,0,,One is if I take my multi-threaded routine and run it with one thread
Dialogue: 0,0:22:43.02,0:22:48.06,Chinese,,0,0,0,,一个是如果我采用我的多线程例程并用一个线程运行它
Dialogue: 0,0:22:48.72,0:22:51.54,English,,0,0,0,,And then I met do it with pthreads or cores
Dialogue: 0,0:22:48.72,0:22:51.54,Chinese,,0,0,0,,然后我遇到了pthreads或核心
Dialogue: 0,0:22:52.16,0:22:53.18,English,,0,0,0,,I can get a speed-up
Dialogue: 0,0:22:52.16,0:22:53.18,Chinese,,0,0,0,,我可以加快速度
Dialogue: 0,0:22:53.32,0:22:59.24,English,,0,0,0,,But actually the true thing is if  take the best-known sequential algorithm for performing this task
Dialogue: 0,0:22:53.32,0:22:59.24,Chinese,,0,0,0,,但实际上真正的问题是如果采用最着名的顺序算法来执行此任务
Dialogue: 0,0:23:00.18,0:23:02.12,English,,0,0,0,,With the best implementation of that
Dialogue: 0,0:23:00.18,0:23:02.12,Chinese,,0,0,0,,有了最好的实施
Dialogue: 0,0:23:02.74,0:23:04.82,English,,0,0,0,,And then compare it against my parallel one
Dialogue: 0,0:23:02.74,0:23:04.82,Chinese,,0,0,0,,然后将它与我的并行比较
Dialogue: 0,0:23:04.84,0:23:07.10,English,,0,0,0,,And so that's referred to as absolute speed-up
Dialogue: 0,0:23:04.84,0:23:07.10,Chinese,,0,0,0,,所以这被称为绝对加速
Dialogue: 0,0:23:08.50,0:23:15.46,English,,0,0,0,,Which is the best measures you know you give both sides the opportunity to do the best implementation that
Dialogue: 0,0:23:08.50,0:23:15.46,Chinese,,0,0,0,,你知道哪种最佳措施可以让双方都有机会做到最好的实施
Dialogue: 0,0:23:15.86,0:23:17.14,English,,0,0,0,,They can and then you compare it
Dialogue: 0,0:23:15.86,0:23:17.14,Chinese,,0,0,0,,他们可以然后你比较它
Dialogue: 0,0:23:18.08,0:23:20.54,English,,0,0,0,,And then what's referred to as the efficiency is
Dialogue: 0,0:23:18.08,0:23:20.54,Chinese,,0,0,0,,然后被称为效率的是什么
Dialogue: 0,0:23:20.98,0:23:26.00,English,,0,0,0,,How close to the speed-up get to the ideal speed-up which is if I'm running on p cores
Dialogue: 0,0:23:20.98,0:23:26.00,Chinese,,0,0,0,,如果我在p核上运行，那么加速到达理想加速的程度如何
Dialogue: 0,0:23:26.80,0:23:28.18,English,,0,0,0,,I should be p times faster
Dialogue: 0,0:23:26.80,0:23:28.18,Chinese,,0,0,0,,我应该快一倍
Dialogue: 0,0:23:28.88,0:23:30.14,English,,0,0,0,,And you'll see that we're
Dialogue: 0,0:23:28.88,0:23:30.14,Chinese,,0,0,0,,你会看到我们是
Dialogue: 0,0:23:30.78,0:23:35.44,English,,0,0,0,,You know the question of hyper-threading versus not we're sort of here we're saying no you don't
Dialogue: 0,0:23:30.78,0:23:35.44,Chinese,,0,0,0,,你知道超线程的问题，而不是我们在这里，我们说不，你不是
Dialogue: 0,0:23:36.38,0:23:39.42,English,,0,0,0,,We're not trying to gain from hyper-threading
Dialogue: 0,0:23:36.38,0:23:39.42,Chinese,,0,0,0,,我们不是试图从超线程中获益
Dialogue: 0,0:23:40.08,0:23:43.32,English,,0,0,0,,You can play this game various ways and you can argue back and forth
Dialogue: 0,0:23:40.08,0:23:43.32,Chinese,,0,0,0,,你可以用各种方式玩这个游戏，你可以反复争辩
Dialogue: 0,0:23:44.44,0:23:46.54,English,,0,0,0,,Whether hyper-threading should count
Dialogue: 0,0:23:44.44,0:23:46.54,Chinese,,0,0,0,,是否应该计算超线程
Dialogue: 0,0:23:46.64,0:23:53.02,English,,0,0,0,,So for p is p the total number of possible threads or the total number of cores
Dialogue: 0,0:23:46.64,0:23:53.02,Chinese,,0,0,0,,因此，对于p，p是可能的线程总数或核心总数
Dialogue: 0,0:23:53.14,0:23:58.40,English,,0,0,0,,It's really a something to argue back and forth about
Dialogue: 0,0:23:53.14,0:23:58.40,Chinese,,0,0,0,,这真的是一种反复争论的东西
Dialogue: 0,0:24:00.24,0:24:08.74,English,,0,0,0,,So the point is the efficiency though is is measured as how much do we do relative to ideal
Dialogue: 0,0:24:00.24,0:24:08.74,Chinese,,0,0,0,,所以关键在于效率虽然衡量的是我们相对于理想的程度
Dialogue: 0,0:24:08.82,0:24:13.16,English,,0,0,0,,And so this is what you get for this code the local version of psum
Dialogue: 0,0:24:08.82,0:24:13.16,Chinese,,0,0,0,,所以这就是你为这段代码获得本地版本的psum
Dialogue: 0,0:24:13.86,0:24:19.22,English,,0,0,0,,You'll see that our efficiency numbers are somewhere in the hi somebody range
Dialogue: 0,0:24:13.86,0:24:19.22,Chinese,,0,0,0,,你会发现我们的效率数字在某个人的范围内
Dialogue: 0,0:24:21.08,0:24:22.26,English,,0,0,0,,Which is good but not great
Dialogue: 0,0:24:21.08,0:24:22.26,Chinese,,0,0,0,,哪个好，但不好
Dialogue: 0,0:24:22.98,0:24:26.32,English,,0,0,0,,It's pretty good actually if you can get 75 percent efficiency
Dialogue: 0,0:24:22.98,0:24:26.32,Chinese,,0,0,0,,如果你能获得75％的效率，那真的很不错
Dialogue: 0,0:24:26.80,0:24:31.62,English,,0,0,0,,You're doing better than most but again that's because this should have been the world's easiest program to parallelize
Dialogue: 0,0:24:26.80,0:24:31.62,Chinese,,0,0,0,,你做得比大多数好，但又是因为这应该是世界上最简单的并行化程序
Dialogue: 0,0:24:33.94,0:24:40.84,English,,0,0,0,,So and the best speed-up we're getting is a factor of six out of eight course so
Dialogue: 0,0:24:33.94,0:24:40.84,Chinese,,0,0,0,,因此，我们获得的最佳加速时间是八分之一的因素
Dialogue: 0,0:24:41.32,0:24:45.58,English,,0,0,0,,Again that's pretty good but this really should be something you can do well
Dialogue: 0,0:24:41.32,0:24:45.58,Chinese,,0,0,0,,再次，这是非常好的，但这应该是你可以做得很好的事情
Dialogue: 0,0:24:47.74,0:24:52.96,English,,0,0,0,,So that just gives you a flavor of what parallel computing can be
Dialogue: 0,0:24:47.74,0:24:52.96,Chinese,,0,0,0,,这样只会让你了解并行计算的内容
Dialogue: 0,0:24:54.08,0:24:59.44,English,,0,0,0,,So now it's sort of back off and talk some general principles just like the speed-up
Dialogue: 0,0:24:54.08,0:24:59.44,Chinese,,0,0,0,,所以现在它有点退缩，并谈论一些一般原则，就像加速一样
Dialogue: 0,0:25:00.80,0:25:04.80,English,,0,0,0,,There's a fella named Gene Amdahl who coincidentally just died a few weeks ago
Dialogue: 0,0:25:00.80,0:25:04.80,Chinese,,0,0,0,,有一个名叫Gene Amdahl的家伙几个星期前刚刚去世
Dialogue: 0,0:25:04.84,0:25:06.28,English,,0,0,0,,He might have seen it in the news
Dialogue: 0,0:25:04.84,0:25:06.28,Chinese,,0,0,0,,他可能在新闻中看到了这一点
Dialogue: 0,0:25:06.72,0:25:11.42,English,,0,0,0,,He was one of the original pioneers at IBM in their mainframe computers
Dialogue: 0,0:25:06.72,0:25:11.42,Chinese,,0,0,0,,他是IBM大型计算机领域最初的先驱之一
Dialogue: 0,0:25:12.36,0:25:16.48,English,,0,0,0,,Then then at some point he in the 60s
Dialogue: 0,0:25:12.36,0:25:16.48,Chinese,,0,0,0,,然后在某些时候他在60年代
Dialogue: 0,0:25:16.88,0:25:19.48,English,,0,0,0,,He started his own company called Amdahl computers
Dialogue: 0,0:25:16.88,0:25:19.48,Chinese,,0,0,0,,他创办了自己的公司Amdahl计算机
Dialogue: 0,0:25:19.48,0:25:24.58,English,,0,0,0,,And they were like they were the cool company in mainframe computers
Dialogue: 0,0:25:19.48,0:25:24.58,Chinese,,0,0,0,,他们就像是大型计算机中的酷公司
Dialogue: 0,0:25:24.58,0:25:27.36,English,,0,0,0,,If that could ever be considered cool right
Dialogue: 0,0:25:24.58,0:25:27.36,Chinese,,0,0,0,,如果这可能被认为是酷的权利
Dialogue: 0,0:25:28.28,0:25:33.04,English,,0,0,0,,And he built a competitor's to IBM that absolutely drove them crazy
Dialogue: 0,0:25:28.28,0:25:33.04,Chinese,,0,0,0,,他为IBM建立了一个竞争对手，绝对让他们疯狂
Dialogue: 0,0:25:33.06,0:25:38.79,English,,0,0,0,,Because they had a virtual monopoly they actually were subject to antitrust suit
Dialogue: 0,0:25:33.06,0:25:38.79,Chinese,,0,0,0,,因为他们实际上是垄断的，所以他们实际上受到了反垄断诉讼
Dialogue: 0,0:25:38.88,0:25:45.80,English,,0,0,0,,So Amdahl was a sort of the the rebel who broke away from the mother company and started a competitor
Dialogue: 0,0:25:38.88,0:25:45.80,Chinese,,0,0,0,,所以阿姆达尔是一个叛逆者，他脱离了母公司并成立了竞争对手
Dialogue: 0,0:25:47.74,0:25:51.44,English,,0,0,0,,And he made this very simple observation that's called Amdahl law
Dialogue: 0,0:25:47.74,0:25:51.44,Chinese,,0,0,0,,他做了一个非常简单的观察，叫做阿姆达尔定律
Dialogue: 0,0:25:51.44,0:25:56.80,English,,0,0,0,,Which is basically junior high level algebra to think of this
Dialogue: 0,0:25:51.44,0:25:56.80,Chinese,,0,0,0,,这基本上是初级高等代数
Dialogue: 0,0:25:56.96,0:25:59.20,English,,0,0,0,,But it's actually a fairly perceptive point
Dialogue: 0,0:25:56.96,0:25:59.20,Chinese,,0,0,0,,但它实际上是一个相当敏锐的观点
Dialogue: 0,0:26:00.02,0:26:03.74,English,,0,0,0,,About what's the possible benefit of speeding up something
Dialogue: 0,0:26:00.02,0:26:03.74,Chinese,,0,0,0,,关于加速某些事情可能带来的好处
Dialogue: 0,0:26:04.14,0:26:05.72,English,,0,0,0,,And this is discussed in the book
Dialogue: 0,0:26:04.14,0:26:05.72,Chinese,,0,0,0,,这在书中讨论过
Dialogue: 0,0:26:06.16,0:26:09.78,English,,0,0,0,,You know this isn't just for computers it's any process that you want to speed up
Dialogue: 0,0:26:06.16,0:26:09.78,Chinese,,0,0,0,,你知道这不仅仅适用于计算机，而是你希望加速的任何过程
Dialogue: 0,0:26:10.40,0:26:16.22,English,,0,0,0,,And it's a very simple observation which is suppose there's some fraction of a system
Dialogue: 0,0:26:10.40,0:26:16.22,Chinese,,0,0,0,,这是一个非常简单的观察，假设有一部分系统
Dialogue: 0,0:26:16.22,0:26:19.90,English,,0,0,0,,That I can make go faster and I'll call that fraction P
Dialogue: 0,0:26:16.22,0:26:19.90,Chinese,,0,0,0,,我可以加快速度，我会称之为P分数
Dialogue: 0,0:26:20.44,0:26:26.72,English,,0,0,0,,P is some number between zero and one point zero right 100% 0%
Dialogue: 0,0:26:20.44,0:26:26.72,Chinese,,0,0,0,,P是零到一点零之间的一些数字右100％0％
Dialogue: 0,0:26:27.96,0:26:31.46,English,,0,0,0,,And let's suppose we take that part that we're going to make run faster
Dialogue: 0,0:26:27.96,0:26:31.46,Chinese,,0,0,0,,让我们假设我们采取那一部分，我们将更快地运行
Dialogue: 0,0:26:31.86,0:26:34.24,English,,0,0,0,,And improve its performance by a factor K
Dialogue: 0,0:26:31.86,0:26:34.24,Chinese,,0,0,0,,并通过K因子提高其性能
Dialogue: 0,0:26:37.08,0:26:42.52,English,,0,0,0,,Then we can just very simply talk about what will be the benefit of that performance
Dialogue: 0,0:26:37.08,0:26:42.52,Chinese,,0,0,0,,然后我们可以非常简单地谈谈该性能的好处
Dialogue: 0,0:26:42.70,0:26:44.04,English,,0,0,0,,So we'll call it T(k)
Dialogue: 0,0:26:42.70,0:26:44.04,Chinese,,0,0,0,,所以我们称之为T（k）
Dialogue: 0,0:26:44.76,0:26:52.00,English,,0,0,0,,And what it says is the fraction P of the time will be reduced by k
Dialogue: 0,0:26:44.76,0:26:52.00,Chinese,,0,0,0,,而它所说的是时间的分数P将减少k
Dialogue: 0,0:26:52.98,0:26:59.30,English,,0,0,0,,But the fraction that you can't change a 1-p will remain at its old time
Dialogue: 0,0:26:52.98,0:26:59.30,Chinese,,0,0,0,,但是你不能改变1-p的分数将保持在旧时代
Dialogue: 0,0:27:00.07,0:27:03.56,English,,0,0,0,,And that's Amdahl law that's it,that's the whole thing
Dialogue: 0,0:27:00.07,0:27:03.56,Chinese,,0,0,0,,这就是Amdahl法则就是这样，这就是整个事情
Dialogue: 0,0:27:03.98,0:27:05.46,English,,0,0,0,,And one interesting measure
Dialogue: 0,0:27:03.98,0:27:05.46,Chinese,,0,0,0,,还有一个有趣的措施
Dialogue: 0,0:27:05.94,0:27:11.00,English,,0,0,0,,What if k were infinity what if we had unbounded resources to speed things up
Dialogue: 0,0:27:05.94,0:27:11.00,Chinese,,0,0,0,,如果k是无限的，如果我们有无限的资源加速的话会怎么样？
Dialogue: 0,0:27:11.86,0:27:18.92,English,,0,0,0,,And what the observation is the best feed up you'll get is a 1-p
Dialogue: 0,0:27:11.86,0:27:18.92,Chinese,,0,0,0,,而观察结果是你获得的最佳效果是1-p
Dialogue: 0,0:27:20.44,0:27:24.88,English,,0,0,0,,And so just think it this way if you have 10% of it that you can't change
Dialogue: 0,0:27:20.44,0:27:24.88,Chinese,,0,0,0,,因此，如果你有10％的不可改变的话，就这样想吧
Dialogue: 0,0:27:26.02,0:27:29.56,English,,0,0,0,,The other 90% you make infinitely fast
Dialogue: 0,0:27:26.02,0:27:29.56,Chinese,,0,0,0,,另外90％你做得非常快
Dialogue: 0,0:27:31.24,0:27:33.76,English,,0,0,0,,Then your performance improvement will be a factor of 10
Dialogue: 0,0:27:31.24,0:27:33.76,Chinese,,0,0,0,,那么你的性能提升将是10倍
Dialogue: 0,0:27:34.16,0:27:37.32,English,,0,0,0,,That's really all it's saying right pretty straightforward idea
Dialogue: 0,0:27:34.16,0:27:37.32,Chinese,,0,0,0,,这就是所有它说的非常直接的想法
Dialogue: 0,0:27:38.56,0:27:41.10,English,,0,0,0,,So this has sort of direct implications in
Dialogue: 0,0:27:38.56,0:27:41.10,Chinese,,0,0,0,,所以这有一些直接影响
Dialogue: 0,0:27:41.40,0:27:48.00,English,,0,0,0,,So the example is suppose that we can improve the performance of some system of 90% of it
Dialogue: 0,0:27:41.40,0:27:48.00,Chinese,,0,0,0,,所以这个例子假设我们可以提高90％的某些系统的性能
Dialogue: 0,0:27:49.04,0:27:53.22,English,,0,0,0,,And we can speed up by factor 9 and that number is chosen to make the numbers work out
Dialogue: 0,0:27:49.04,0:27:53.22,Chinese,,0,0,0,,我们可以加速9倍，并选择该数字来使数字成功
Dialogue: 0,0:27:53.72,0:27:57.22,English,,0,0,0,,Then we'll get it best at 2x performance improvement
Dialogue: 0,0:27:53.72,0:27:57.22,Chinese,,0,0,0,,那么我们将在性能提升2倍时获得最佳效果
Dialogue: 0,0:27:57.66,0:28:02.64,English,,0,0,0,,Basically what it says is the part of the system that you can't speed up will become your bottleneck
Dialogue: 0,0:27:57.66,0:28:02.64,Chinese,,0,0,0,,基本上它所说的系统中你无法加速的部分将成为你的瓶颈
Dialogue: 0,0:28:04.02,0:28:06.08,English,,0,0,0,,And that's just the way it is
Dialogue: 0,0:28:04.02,0:28:06.08,Chinese,,0,0,0,,这就是它的方式
Dialogue: 0,0:28:06.24,0:28:09.58,English,,0,0,0,,So the implications for this repair while programming are fairly obvious
Dialogue: 0,0:28:06.24,0:28:09.58,Chinese,,0,0,0,,因此编程时对此修复的影响相当明显
Dialogue: 0,0:28:09.74,0:28:14.00,English,,0,0,0,,That if we can take our application and chop off some fraction of it
Dialogue: 0,0:28:09.74,0:28:14.00,Chinese,,0,0,0,,如果我们可以采取我们的应用程序并切断它的一部分
Dialogue: 0,0:28:14.60,0:28:18.18,English,,0,0,0,,And make it run k times faster by running it on k cores
Dialogue: 0,0:28:14.60,0:28:18.18,Chinese,,0,0,0,,并通过在k核上运行它使运行速度提高k倍
Dialogue: 0,0:28:19.74,0:28:28.12,English,,0,0,0,,Then the part of it that's still running sequentially will come to will limit the ultimate performance
Dialogue: 0,0:28:19.74,0:28:28.12,Chinese,,0,0,0,,然后它仍然按顺序运行的部分将限制最终性能
Dialogue: 0,0:28:30.18,0:28:33.62,English,,0,0,0,,We can get so that's not really an issue for this summation problem
Dialogue: 0,0:28:30.18,0:28:33.62,Chinese,,0,0,0,,我们可以得到这个并不是这个求和问题的真正问题
Dialogue: 0,0:28:33.62,0:28:37.56,English,,0,0,0,,Because it really does divide into as many independent tasks
Dialogue: 0,0:28:33.62,0:28:37.56,Chinese,,0,0,0,,因为它确实分成了许多独立的任务
Dialogue: 0,0:28:37.76,0:28:40.34,English,,0,0,0,,As as you have numbers and
Dialogue: 0,0:28:37.76,0:28:40.34,Chinese,,0,0,0,,就像你有数字和
Dialogue: 0,0:28:40.88,0:28:42.60,English,,0,0,0,,As you can see you can make them run
Dialogue: 0,0:28:40.88,0:28:42.60,Chinese,,0,0,0,,如你所见，你可以让它们运行
Dialogue: 0,0:28:42.60,0:28:46.64,English,,0,0,0,,But many other applications do some part of it that I can't really make know parallel
Dialogue: 0,0:28:42.60,0:28:46.64,Chinese,,0,0,0,,但是许多其他应用程序在其中做了一些我无法实现并行的部分
Dialogue: 0,0:28:49.42,0:28:54.10,English,,0,0,0,,So just as an example and just for the sake of this class
Dialogue: 0,0:28:49.42,0:28:54.10,Chinese,,0,0,0,,所以只是作为一个例子，只是为了这个班级
Dialogue: 0,0:28:54.28,0:28:59.70,English,,0,0,0,,You know an example of a little bit more involved a problem in parallel programming and multi-threading
Dialogue: 0,0:28:54.28,0:28:59.70,Chinese,,0,0,0,,你知道更多涉及并行编程和多线程问题的示例
Dialogue: 0,0:29:00.10,0:29:02.44,English,,0,0,0,,Let's think about sorting a bunch of numbers
Dialogue: 0,0:29:00.10,0:29:02.44,Chinese,,0,0,0,,让我们考虑排序一堆数字
Dialogue: 0,0:29:02.52,0:29:05.84,English,,0,0,0,,So we have n numbers and we want to sort them
Dialogue: 0,0:29:02.52,0:29:05.84,Chinese,,0,0,0,,所以我们有n个数字，我们想要对它们进行排序
Dialogue: 0,0:29:08.86,0:29:13.56,English,,0,0,0,,And we have some number of threads
Dialogue: 0,0:29:08.86,0:29:13.56,Chinese,,0,0,0,,我们有一些线程
Dialogue: 0,0:29:13.56,0:29:16.52,English,,0,0,0,,That we can do this with is there way we can speed this up
Dialogue: 0,0:29:13.56,0:29:16.52,Chinese,,0,0,0,,我们可以做到这一点，我们可以加快速度
Dialogue: 0,0:29:17.30,0:29:20.26,English,,0,0,0,,And you think about it's not that clear how you do it
Dialogue: 0,0:29:17.30,0:29:20.26,Chinese,,0,0,0,,你想想你怎么做的并不清楚
Dialogue: 0,0:29:20.26,0:29:23.28,English,,0,0,0,,There's actually a vast literature in parallel sorting
Dialogue: 0,0:29:20.26,0:29:23.28,Chinese,,0,0,0,,实际上有大量并行排序的文献
Dialogue: 0,0:29:23.76,0:29:29.24,English,,0,0,0,,And those you've taken or won't take the class 210 will be exposed to a lot of this
Dialogue: 0,0:29:23.76,0:29:29.24,Chinese,,0,0,0,,那些你已经或不会参加210级课程的人将会接触到很多这样的知识
Dialogue: 0,0:29:29.76,0:29:32.80,English,,0,0,0,,But I'm just going to do a very simple version which is quicksort
Dialogue: 0,0:29:29.76,0:29:32.80,Chinese,,0,0,0,,但我只是想做一个非常简单的版本，这是快速的
Dialogue: 0,0:29:34.16,0:29:36.68,English,,0,0,0,,So quicksort is for example the
Dialogue: 0,0:29:34.16,0:29:36.68,Chinese,,0,0,0,,所以快速排序就是这样的
Dialogue: 0,0:29:40.78,0:29:50.72,English,,0,0,0,,The C library program qsort quicksort it was invented in the early 1960s or 1950s by a guy named Tony Hoare
Dialogue: 0,0:29:40.78,0:29:50.72,Chinese,,0,0,0,,C库程序qsort quicksort它是在20世纪60年代或者20世纪50年代由一个叫Tony Hoare的人发明的
Dialogue: 0,0:29:51.58,0:29:55.12,English,,0,0,0,,Who also founded a lot of the fundamental logic of program
Dialogue: 0,0:29:51.58,0:29:55.12,Chinese,,0,0,0,,谁也创立了很多程序的基本逻辑
Dialogue: 0,0:29:55.24,0:30:00.96,English,,0,0,0,,So he's like an amazing person still alive today lives in Cambridge England
Dialogue: 0,0:29:55.24,0:30:00.96,Chinese,,0,0,0,,所以他就像一个仍然活着的人今天住在英国剑桥
Dialogue: 0,0:30:01.56,0:30:07.42,English,,0,0,0,,But if you ever have a chance to go to a talk by him do so he's amazing person
Dialogue: 0,0:30:01.56,0:30:07.42,Chinese,,0,0,0,,但如果你有机会去参加他的演讲，那么他就是一个很棒的人
Dialogue: 0,0:30:08.14,0:30:13.82,English,,0,0,0,,Anyways the idea quicksort is very simple and this is sort of the basic sorting algorithm
Dialogue: 0,0:30:08.14,0:30:13.82,Chinese,,0,0,0,,无论如何，想法quicksort非常简单，这是一种基本的排序算法
Dialogue: 0,0:30:13.84,0:30:18.24,English,,0,0,0,,You grab some element from the array that you're trying to sort
Dialogue: 0,0:30:13.84,0:30:18.24,Chinese,,0,0,0,,你从你想要排序的数组中获取一些元素
Dialogue: 0,0:30:18.72,0:30:19.68,English,,0,0,0,,That's called the pivot
Dialogue: 0,0:30:18.72,0:30:19.68,Chinese,,0,0,0,,那被称为枢轴
Dialogue: 0,0:30:20.42,0:30:27.68,English,,0,0,0,,And then you split the data so that you look at the elements that are either greater or less than the pivot
Dialogue: 0,0:30:20.42,0:30:27.68,Chinese,,0,0,0,,然后分割数据，以便查看大于或小于数据透视表的元素
Dialogue: 0,0:30:28.10,0:30:32.02,English,,0,0,0,,And potentially also equal let's just assume all the elements are unique here
Dialogue: 0,0:30:28.10,0:30:32.02,Chinese,,0,0,0,,并且也可能等于让我们假设所有元素在这里都是唯一的
Dialogue: 0,0:30:32.56,0:30:36.94,English,,0,0,0,,So you just split it into two piles one is the less, one is a greater
Dialogue: 0,0:30:32.56,0:30:36.94,Chinese,,0,0,0,,所以你只需把它分成两堆，一个是少，一个是更大
Dialogue: 0,0:30:37.42,0:30:41.12,English,,0,0,0,,Now you creatively you recursively you sort those two piles
Dialogue: 0,0:30:37.42,0:30:41.12,Chinese,,0,0,0,,现在你创造性地递归地对这两堆进行排序
Dialogue: 0,0:30:42.50,0:30:46.42,English,,0,0,0,,By the same method and when it's all done you end up with everything sorted
Dialogue: 0,0:30:42.50,0:30:46.42,Chinese,,0,0,0,,通过相同的方法，当它全部完成时，你最终将所有内容排序
Dialogue: 0,0:30:46.86,0:30:51.00,English,,0,0,0,,One nice thing about it is it can be done in place meaning if you have an array of data
Dialogue: 0,0:30:46.86,0:30:51.00,Chinese,,0,0,0,,关于它的一个好处是它可以在适当的位置完成，这意味着如果你有一个数据数组
Dialogue: 0,0:30:51.44,0:30:57.36,English,,0,0,0,,You can do this all just by swapping elements around and not have to use any extra space
Dialogue: 0,0:30:51.44,0:30:57.36,Chinese,,0,0,0,,你可以通过交换元素来完成这一切，而不必使用任何额外的空间
Dialogue: 0,0:30:57.50,0:30:59.44,English,,0,0,0,,Which you would for example with merge sort
Dialogue: 0,0:30:57.50,0:30:59.44,Chinese,,0,0,0,,以合并排序为例
Dialogue: 0,0:31:00.14,0:31:05.28,English,,0,0,0,,So this is a fairly simple algorithm and just to visualize it then
Dialogue: 0,0:31:00.14,0:31:05.28,Chinese,,0,0,0,,所以这是一个相当简单的算法，然后只是想象它
Dialogue: 0,0:31:06.06,0:31:09.62,English,,0,0,0,,You have some block of data X array and you want to sort it
Dialogue: 0,0:31:06.06,0:31:09.62,Chinese,,0,0,0,,你有一些数据块X阵列，你想要对它进行排序
Dialogue: 0,0:31:09.70,0:31:13.70,English,,0,0,0,,So you pick an element called the pivot and there's various strategies for doing that
Dialogue: 0,0:31:09.70,0:31:13.70,Chinese,,0,0,0,,所以你选择了一个名为pivot的元素，并且有各种策略可以做到这一点
Dialogue: 0,0:31:14.88,0:31:19.42,English,,0,0,0,,And now you just subdivide X into three parts
Dialogue: 0,0:31:14.88,0:31:19.42,Chinese,,0,0,0,,现在你只需将X细分为三个部分
Dialogue: 0,0:31:19.56,0:31:24.52,English,,0,0,0,,L the left hand P the right hand meaning less and greater than p
Dialogue: 0,0:31:19.56,0:31:24.52,Chinese,,0,0,0,,L左手P右手意味着小于和大于p
Dialogue: 0,0:31:25.06,0:31:26.82,English,,0,0,0,,And then you place p in the middle
Dialogue: 0,0:31:25.06,0:31:26.82,Chinese,,0,0,0,,然后你把p放在中间
Dialogue: 0,0:31:27.78,0:31:33.48,English,,0,0,0,,And then you recursively when you're doing this for in a sequential code
Dialogue: 0,0:31:27.78,0:31:33.48,Chinese,,0,0,0,,然后，当你在顺序代码中执行此操作时递归
Dialogue: 0,0:31:33.48,0:31:39.03,English,,0,0,0,,You'll pick one of these two usually leftmost or rightmost whatever doesn't really matter
Dialogue: 0,0:31:33.48,0:31:39.03,Chinese,,0,0,0,,你会选择这两个中的一个通常最左边或最右边的任何无关紧要的东西
Dialogue: 0,0:31:39.40,0:31:46.57,English,,0,0,0,,And you'll recursively you apply the same method to the left side and
Dialogue: 0,0:31:39.40,0:31:46.57,Chinese,,0,0,0,,并且你将递归地将相同的方法应用于左侧和
Dialogue: 0,0:31:46.86,0:31:51.96,English,,0,0,0,,And ultimately after enough recursions you get to the point where L has been sorted
Dialogue: 0,0:31:46.86,0:31:51.96,Chinese,,0,0,0,,并且最终在经过足够的递归后，你将达到L已经排序的程度
Dialogue: 0,0:31:52.24,0:31:55.22,English,,0,0,0,,And that's shown in this kind of a swishy color thing
Dialogue: 0,0:31:52.24,0:31:55.22,Chinese,,0,0,0,,这就是这种闪闪发光的颜色
Dialogue: 0,0:31:55.76,0:31:57.04,English,,0,0,0,,And call that L'
Dialogue: 0,0:31:55.76,0:31:57.04,Chinese,,0,0,0,,并称之为L'
Dialogue: 0,0:31:57.98,0:31:59.30,English,,0,0,0,,And same with
Dialogue: 0,0:31:57.98,0:31:59.30,Chinese,,0,0,0,,同样的
Dialogue: 0,0:32:03.86,0:32:07.16,English,,0,0,0,,You'll do the same thing now with the right hand side
Dialogue: 0,0:32:03.86,0:32:07.16,Chinese,,0,0,0,,你现在用右手做同样的事情
Dialogue: 0,0:32:07.62,0:32:10.14,English,,0,0,0,,And when you're done this is usually done in place
Dialogue: 0,0:32:07.62,0:32:10.14,Chinese,,0,0,0,,当你完成这项工作通常是在适当的地方完成的
Dialogue: 0,0:32:10.28,0:32:16.52,English,,0,0,0,,So you just the L part works on one array part of the array and the are part on another
Dialogue: 0,0:32:10.28,0:32:16.52,Chinese,,0,0,0,,所以你只是L部分在数组的一个数组部分上工作，而在另一部分的数组部分
Dialogue: 0,0:32:16.94,0:32:18.38,English,,0,0,0,,And when you're done they're in sorted order
Dialogue: 0,0:32:16.94,0:32:18.38,Chinese,,0,0,0,,当你完成它们时，它们按顺序排列
Dialogue: 0,0:32:20.26,0:32:23.18,English,,0,0,0,,The very simple sort and generally has very good performance
Dialogue: 0,0:32:20.26,0:32:23.18,Chinese,,0,0,0,,非常简单的排序，通常具有非常好的性能
Dialogue: 0,0:32:24.64,0:32:30.54,English,,0,0,0,,So this is what the code for it looks like which is usually you have is a special case
Dialogue: 0,0:32:24.64,0:32:30.54,Chinese,,0,0,0,,所以这就是它的代码看起来通常你有一个特例
Dialogue: 0,0:32:30.54,0:32:31.94,English,,0,0,0,,If there's only one or two elements
Dialogue: 0,0:32:30.54,0:32:31.94,Chinese,,0,0,0,,如果只有一个或两个元素
Dialogue: 0,0:32:33.04,0:32:35.28,English,,0,0,0,,And then you do this partitioning
Dialogue: 0,0:32:33.04,0:32:35.28,Chinese,,0,0,0,,然后你做这个分区
Dialogue: 0,0:32:35.28,0:32:41.50,English,,0,0,0,,So this routine of splitting it between the left and the right hand part is handled by a function called partition
Dialogue: 0,0:32:35.28,0:32:41.50,Chinese,,0,0,0,,因此，在左手和右手之间分割它的这个例程由一个称为分区的函数处理
Dialogue: 0,0:32:42.36,0:32:46.22,English,,0,0,0,,And then if there's more than one element in the left side
Dialogue: 0,0:32:42.36,0:32:46.22,Chinese,,0,0,0,,然后，如果左侧有多个元素
Dialogue: 0,0:32:46.22,0:32:51.92,English,,0,0,0,,You sort that and if there's more than one element in the right hand side you sort that
Dialogue: 0,0:32:46.22,0:32:51.92,Chinese,,0,0,0,,你可以对它进行排序，如果右侧有多个元素，则可以对其进行排序
Dialogue: 0,0:32:53.68,0:32:58.66,English,,0,0,0,,And then when all these recursions are done then the array is sorted
Dialogue: 0,0:32:53.68,0:32:58.66,Chinese,,0,0,0,,然后，当完成所有这些递归之后，对数组进行排序
Dialogue: 0,0:32:59.30,0:33:04.04,English,,0,0,0,,So pretty typical code and we won't go in the trickiest part writing the code is
Dialogue: 0,0:32:59.30,0:33:04.04,Chinese,,0,0,0,,所以非常典型的代码，我们不会进入编写代码的最棘手的部分
Dialogue: 0,0:33:04.12,0:33:06.96,English,,0,0,0,,How do you make this partitioning go fast
Dialogue: 0,0:33:04.12,0:33:06.96,Chinese,,0,0,0,,你如何让这个分区变得更快
Dialogue: 0,0:33:07.70,0:33:10.18,English,,0,0,0,,But I won't go into that just imagine it happens
Dialogue: 0,0:33:07.70,0:33:10.18,Chinese,,0,0,0,,但我不会想到它只是想象它会发生
Dialogue: 0,0:33:11.74,0:33:15.90,English,,0,0,0,,So this algorithm actually has a natural version of parallelism
Dialogue: 0,0:33:11.74,0:33:15.90,Chinese,,0,0,0,,所以这个算法实际上有一个自然版本的并行性
Dialogue: 0,0:33:16.28,0:33:20.58,English,,0,0,0,,Which is in my sequential version I was sorting both first the left
Dialogue: 0,0:33:16.28,0:33:20.58,Chinese,,0,0,0,,在我的顺序版本中，我首先在左边排序
Dialogue: 0,0:33:20.72,0:33:24.98,English,,0,0,0,,And then the left of the left and the left of the left of the left and kind of working my way
Dialogue: 0,0:33:20.72,0:33:24.98,Chinese,,0,0,0,,然后是左边左边左边的左边，有点像我一样
Dialogue: 0,0:33:25.40,0:33:27.50,English,,0,0,0,,Until I got that whole array sorted
Dialogue: 0,0:33:25.40,0:33:27.50,Chinese,,0,0,0,,直到我得到整个数组排序
Dialogue: 0,0:33:27.78,0:33:30.44,English,,0,0,0,,And then I was coming back and I was working on the right
Dialogue: 0,0:33:27.78,0:33:30.44,Chinese,,0,0,0,,然后我回来了，我正在努力
Dialogue: 0,0:33:30.44,0:33:33.82,English,,0,0,0,,And then the left part of the right and the left to the left to the right and blah blah blah
Dialogue: 0,0:33:30.44,0:33:33.82,Chinese,,0,0,0,,然后是右边的左边部分和左边的左边部分，等等等等等等
Dialogue: 0,0:33:34.44,0:33:37.54,English,,0,0,0,,And doing these recursions because the way the codes written
Dialogue: 0,0:33:34.44,0:33:37.54,Chinese,,0,0,0,,并且因为编写代码的方式进行这些递归
Dialogue: 0,0:33:40.18,0:33:44.50,English,,0,0,0,,Right I am doing the full sort of the left-hand part
Dialogue: 0,0:33:40.18,0:33:44.50,Chinese,,0,0,0,,对，我正在完成左手部分
Dialogue: 0,0:33:45.16,0:33:49.60,English,,0,0,0,,And only after that is sorted then I'm doing the complete sort of the right-hand part
Dialogue: 0,0:33:45.16,0:33:49.60,Chinese,,0,0,0,,只有在那之后才进行排序，然后我就完成了右手部分
Dialogue: 0,0:33:49.78,0:33:56.94,English,,0,0,0,,So the point is it's an algorithm where I'm working just on one part of the array of the time
Dialogue: 0,0:33:49.78,0:33:56.94,Chinese,,0,0,0,,所以重点是它是一种算法，我只是在一部分时间上工作
Dialogue: 0,0:33:58.10,0:34:01.86,English,,0,0,0,,But there's a very natural recursion of parallelism here that says
Dialogue: 0,0:33:58.10,0:34:01.86,Chinese,,0,0,0,,但是这里有一个非常自然的并行递归
Dialogue: 0,0:34:02.30,0:34:05.84,English,,0,0,0,,Okay I've got two parts they each need to be sorted
Dialogue: 0,0:34:02.30,0:34:05.84,Chinese,,0,0,0,,好的，我有两个部分，他们每个都需要分类
Dialogue: 0,0:34:06.28,0:34:10.76,English,,0,0,0,,Let me just fire off two threads and let them do with that
Dialogue: 0,0:34:06.28,0:34:10.76,Chinese,,0,0,0,,让我开始关闭两个线程并让它们做到这一点
Dialogue: 0,0:34:12.30,0:34:16.54,English,,0,0,0,,And that's the so it's what you call divide and conquer parallelism
Dialogue: 0,0:34:12.30,0:34:16.54,Chinese,,0,0,0,,这就是你所谓的分裂并征服并行性
Dialogue: 0,0:34:16.60,0:34:20.38,English,,0,0,0,,It's a very natural kind of parallelism it shows up in this code
Dialogue: 0,0:34:16.60,0:34:20.38,Chinese,,0,0,0,,这是一种非常自然的并行性，它出现在这段代码中
Dialogue: 0,0:34:23.40,0:34:26.68,English,,0,0,0,,So basically I'll do the same thing as before all at
Dialogue: 0,0:34:23.40,0:34:26.68,Chinese,,0,0,0,,所以基本上我会做同样的事情
Dialogue: 0,0:34:26.90,0:34:31.44,English,,0,0,0,,The top level will be a purely sequential process of partitioning
Dialogue: 0,0:34:26.90,0:34:31.44,Chinese,,0,0,0,,顶级将是纯粹顺序的分区过程
Dialogue: 0,0:34:32.60,0:34:38.50,English,,0,0,0,,And but then assuming a partition comes up with some non-trivial split
Dialogue: 0,0:34:32.60,0:34:38.50,Chinese,,0,0,0,,然而，假设一个分区出现了一些非平凡的分裂
Dialogue: 0,0:34:39.08,0:34:44.28,English,,0,0,0,,Then I will recursively begin fork off to threads
Dialogue: 0,0:34:39.08,0:34:44.28,Chinese,,0,0,0,,然后我会递归地开始fork到线程
Dialogue: 0,0:34:44.94,0:34:47.40,English,,0,0,0,,Each of which will be responsible for the other and
Dialogue: 0,0:34:44.94,0:34:47.40,Chinese,,0,0,0,,其中每一个都将负责另一个和
Dialogue: 0,0:34:47.40,0:34:51.44,English,,0,0,0,,So we'll sort of look like I'm working on the two parts in parallel
Dialogue: 0,0:34:47.40,0:34:51.44,Chinese,,0,0,0,,所以我们看起来就像是在并行处理这两个部分
Dialogue: 0,0:34:52.26,0:34:54.68,English,,0,0,0,,And eventually both sides will end up
Dialogue: 0,0:34:52.26,0:34:54.68,Chinese,,0,0,0,,最终双方都会结束
Dialogue: 0,0:34:55.18,0:34:59.08,English,,0,0,0,,Now this picture isn't really quite true and that it looked makes it look like
Dialogue: 0,0:34:55.18,0:34:59.08,Chinese,,0,0,0,,现在这张照片真的不太真实，而且看起来很像
Dialogue: 0,0:34:59.52,0:35:05.44,English,,0,0,0,,They're all kind of synchronized together and I'm doing a you know kaboom down like this
Dialogue: 0,0:34:59.52,0:35:05.44,Chinese,,0,0,0,,他们都是同步在一起的，我正在做你知道的kaboom就像这样
Dialogue: 0,0:35:05.66,0:35:09.02,English,,0,0,0,,In a strict way but in fact they're not it's very asynchronous
Dialogue: 0,0:35:05.66,0:35:09.02,Chinese,,0,0,0,,严格地说，但事实上它们不是非常不同步
Dialogue: 0,0:35:09.66,0:35:12.50,English,,0,0,0,,The left part is one thread the right is another
Dialogue: 0,0:35:09.66,0:35:12.50,Chinese,,0,0,0,,左边是一个线程，右边是另一个
Dialogue: 0,0:35:13.06,0:35:19.30,English,,0,0,0,,They just go at their own pace and at the end I'm just going to wait for it all to complete
Dialogue: 0,0:35:13.06,0:35:19.30,Chinese,,0,0,0,,他们只是按照自己的节奏前进，最后我只是等待一切都完成
Dialogue: 0,0:35:19.74,0:35:23.70,English,,0,0,0,,But there's no strict temporal ordering on how that all occurs
Dialogue: 0,0:35:19.74,0:35:23.70,Chinese,,0,0,0,,但是对于如何发生这一切并没有严格的时间顺序
Dialogue: 0,0:35:28.28,0:35:33.60,English,,0,0,0,,So the way I'll write this in the code is available on the course website
Dialogue: 0,0:35:28.28,0:35:33.60,Chinese,,0,0,0,,因此，我将在课程网站上提供我在代码中编写此代码的方式
Dialogue: 0,0:35:33.60,0:35:35.36,English,,0,0,0,,I'm only going to show you a glimpse of it
Dialogue: 0,0:35:33.60,0:35:35.36,Chinese,,0,0,0,,我只会向你展示一下它
Dialogue: 0,0:35:36.02,0:35:38.40,English,,0,0,0,,It's a non-trivial amount of code it takes to do it
Dialogue: 0,0:35:36.02,0:35:38.40,Chinese,,0,0,0,,这是一个非常重要的代码来完成它
Dialogue: 0,0:35:38.88,0:35:43.36,English,,0,0,0,,But basically what I'm going to do is have a bunch of a pool of threads
Dialogue: 0,0:35:38.88,0:35:43.36,Chinese,,0,0,0,,但基本上我要做的就是拥有一堆线程
Dialogue: 0,0:35:43.98,0:35:48.86,English,,0,0,0,,That are ready to work and that's a pretty typical way you write threaded code
Dialogue: 0,0:35:43.98,0:35:48.86,Chinese,,0,0,0,,这已经准备好了，这是编写线程代码的一种非常典型的方式
Dialogue: 0,0:35:49.60,0:35:56.82,English,,0,0,0,,Because actually the initiation of a thread is a non-trivial amount of computation
Dialogue: 0,0:35:49.60,0:35:56.82,Chinese,,0,0,0,,因为实际上线程的启动是非常重要的计算量
Dialogue: 0,0:35:56.88,0:35:58.16,English,,0,0,0,,So usually what you do is
Dialogue: 0,0:35:56.88,0:35:58.16,Chinese,,0,0,0,,通常你所做的就是
Dialogue: 0,0:35:58.56,0:36:01.18,English,,0,0,0,,You say I've got this many cores
Dialogue: 0,0:35:58.56,0:36:01.18,Chinese,,0,0,0,,你说我有这么多核心
Dialogue: 0,0:36:01.68,0:36:05.76,English,,0,0,0,,I'm going to create a set of that many threads
Dialogue: 0,0:36:01.68,0:36:05.76,Chinese,,0,0,0,,我要创建一组那么多线程
Dialogue: 0,0:36:06.58,0:36:10.95,English,,0,0,0,,And they will each work by sharing a task queue
Dialogue: 0,0:36:06.58,0:36:10.95,Chinese,,0,0,0,,他们将通过共享任务队列来工作
Dialogue: 0,0:36:11.52,0:36:19.34,English,,0,0,0,,So some agent that is a forking off work for the different threads to do
Dialogue: 0,0:36:11.52,0:36:19.34,Chinese,,0,0,0,,所以一些代理人正在为不同的线程做分工
Dialogue: 0,0:36:19.70,0:36:25.38,English,,0,0,0,,They will do the work assigned to them when that's complete they'll come back and say ok I'm ready for something new
Dialogue: 0,0:36:19.70,0:36:25.38,Chinese,,0,0,0,,他们将完成分配给他们的工作，当他们完成后他们会回来说好，我已准备好接受新的事情了
Dialogue: 0,0:36:25.68,0:36:27.02,English,,0,0,0,,And it will give them something new
Dialogue: 0,0:36:25.68,0:36:27.02,Chinese,,0,0,0,,它会给他们一些新的东西
Dialogue: 0,0:36:27.16,0:36:34.54,English,,0,0,0,,So I've there's a little bit of code a very rudimentary code there of creating this task model and task scheduling
Dialogue: 0,0:36:27.16,0:36:34.54,Chinese,,0,0,0,,所以我有一些代码是创建这个任务模型和任务调度的非常基本的代码
Dialogue: 0,0:36:35.52,0:36:38.08,English,,0,0,0,,So the basic rule will be any given task
Dialogue: 0,0:36:35.52,0:36:38.08,Chinese,,0,0,0,,因此，基本规则将是任何给定的任务
Dialogue: 0,0:36:39.02,0:36:46.68,English,,0,0,0,,Any given thread then at any given time has been assigned sub range of this array to be a sorting
Dialogue: 0,0:36:39.02,0:36:46.68,Chinese,,0,0,0,,然后，在任何给定时间的任何给定线程都被指定为该数组的子范围以进行排序
Dialogue: 0,0:36:47.28,0:36:55.66,English,,0,0,0,,And it will be specified by the base meaning the starting point of this particular range
Dialogue: 0,0:36:47.28,0:36:55.66,Chinese,,0,0,0,,并且它将由基数指定，意味着该特定范围的起点
Dialogue: 0,0:36:56.26,0:37:01.26,English,,0,0,0,,And then the number of elements that it's a told it's sort
Dialogue: 0,0:36:56.26,0:37:01.26,Chinese,,0,0,0,,然后它被告知它的元素数量排序
Dialogue: 0,0:37:03.74,0:37:05.70,English,,0,0,0,,And one other thing I'll do is
Dialogue: 0,0:37:03.74,0:37:05.70,Chinese,,0,0,0,,我要做的另一件事是
Dialogue: 0,0:37:06.04,0:37:10.32,English,,0,0,0,,Once get down to this array being small enough
Dialogue: 0,0:37:06.04,0:37:10.32,Chinese,,0,0,0,,一旦得到这个阵列足够小
Dialogue: 0,0:37:10.82,0:37:12.90,English,,0,0,0,,I'll just sort it sequentially
Dialogue: 0,0:37:10.82,0:37:12.90,Chinese,,0,0,0,,我只是顺序排序
Dialogue: 0,0:37:13.60,0:37:20.96,English,,0,0,0,,And and we'll see how big that block is or not is actually performance parameter that you can use for tuning the program
Dialogue: 0,0:37:13.60,0:37:20.96,Chinese,,0,0,0,,并且我们将看到该块有多大，实际上是可用于调整程序的性能参数
Dialogue: 0,0:37:21.82,0:37:25.32,English,,0,0,0,,So the point is that you don't want to take this down too far
Dialogue: 0,0:37:21.82,0:37:25.32,Chinese,,0,0,0,,所以重点是你不想把它放得太远
Dialogue: 0,0:37:25.34,0:37:29.60,English,,0,0,0,,Because the sort of overhead of threads is enough that
Dialogue: 0,0:37:25.34,0:37:29.60,Chinese,,0,0,0,,因为线程的开销就足够了
Dialogue: 0,0:37:29.98,0:37:33.00,English,,0,0,0,,When you get to fine-grained you're actually going to start losing performance
Dialogue: 0,0:37:29.98,0:37:33.00,Chinese,,0,0,0,,当你得到细粒度时，你实际上会开始失去性能
Dialogue: 0,0:37:35.38,0:37:39.48,English,,0,0,0,,So assume that it's bigger than that I've been given some block there
Dialogue: 0,0:37:35.38,0:37:39.48,Chinese,,0,0,0,,因此，假设它比我在那里被给予一些阻止更大
Dialogue: 0,0:37:40.04,0:37:43.78,English,,0,0,0,,What I'll do then is I'll run the partition step
Dialogue: 0,0:37:40.04,0:37:43.78,Chinese,,0,0,0,,那我要做的是我将运行分区步骤
Dialogue: 0,0:37:44.12,0:37:50.50,English,,0,0,0,,This thread will run it a partition step just using the exact function   showed you or didn't show you
Dialogue: 0,0:37:44.12,0:37:50.50,Chinese,,0,0,0,,这个线程将运行它一个分区步骤，只需使用显示你或没有显示给你的确切函数
Dialogue: 0,0:37:52.74,0:38:00.00,English,,0,0,0,,And then as long as and then I will create and add to the task queue two new tasks
Dialogue: 0,0:37:52.74,0:38:00.00,Chinese,,0,0,0,,然后只要我再创建并向任务队列添加两个新任务
Dialogue: 0,0:38:00.84,0:38:05.06,English,,0,0,0,,A one de for the left part and one for the right part
Dialogue: 0,0:38:00.84,0:38:05.06,Chinese,,0,0,0,,左侧部分为一个，右侧部分为一个
Dialogue: 0,0:38:05.78,0:38:13.50,English,,0,0,0,,And then the scheduler that will assign two threads to handle those two parts
Dialogue: 0,0:38:05.78,0:38:13.50,Chinese,,0,0,0,,然后调度程序将分配两个线程来处理这两个部分
Dialogue: 0,0:38:13.68,0:38:16.52,English,,0,0,0,,And so that code will that's exactly how the code is going to work
Dialogue: 0,0:38:13.68,0:38:16.52,Chinese,,0,0,0,,因此，代码将正是代码的工作方式
Dialogue: 0,0:38:16.66,0:38:21.78,English,,0,0,0,,It's going to keep reusing the same threads over and over again
Dialogue: 0,0:38:16.66,0:38:21.78,Chinese,,0,0,0,,它会一遍又一遍地重复使用相同的线程
Dialogue: 0,0:38:22.56,0:38:27.02,English,,0,0,0,,To but at any given time they'll be given a range of places
Dialogue: 0,0:38:22.56,0:38:27.02,Chinese,,0,0,0,,但是在任何时候他们都会得到一系列的地方
Dialogue: 0,0:38:27.86,0:38:30.88,English,,0,0,0,,What typically will happen is they'll run their partitioning step
Dialogue: 0,0:38:27.86,0:38:30.88,Chinese,,0,0,0,,通常会发生的是他们将运行他们的分区步骤
Dialogue: 0,0:38:32.42,0:38:39.98,English,,0,0,0,,And then say okay I've done my job now assigned to new threads to do this and that's the general scheme of it
Dialogue: 0,0:38:32.42,0:38:39.98,Chinese,,0,0,0,,然后说好，我已经完成了我的工作，现在分配到新线程来做这个，这是它的一般方案
Dialogue: 0,0:38:40.12,0:38:42.40,English,,0,0,0,,Or they'll say this is a small enough block
Dialogue: 0,0:38:40.12,0:38:42.40,Chinese,,0,0,0,,或者他们会说这是一个足够小的块
Dialogue: 0,0:38:43.26,0:38:45.72,English,,0,0,0,,I'm just going to sort the darn thing
Dialogue: 0,0:38:43.26,0:38:45.72,Chinese,,0,0,0,,我只想解决这个问题
Dialogue: 0,0:38:45.76,0:38:48.16,English,,0,0,0,,Okay so that's really all the code does it's online
Dialogue: 0,0:38:45.76,0:38:48.16,Chinese,,0,0,0,,好的，这就是所有的代码都是在线的
Dialogue: 0,0:38:48.68,0:38:54.94,English,,0,0,0,,If you're interested in this kind of stuff it's... I think it's pretty well written code because  wrote
Dialogue: 0,0:38:48.68,0:38:54.94,Chinese,,0,0,0,,如果你对这种东西感兴趣那就是......我认为这是写得很好的代码
Dialogue: 0,0:38:57.62,0:39:00.52,English,,0,0,0,,It so this is sort of that the
Dialogue: 0,0:38:57.62,0:39:00.52,Chinese,,0,0,0,,它就是这样的
Dialogue: 0,0:39:01.50,0:39:04.66,English,,0,0,0,,Somewhat simplified version of the code say
Dialogue: 0,0:39:01.50,0:39:04.66,Chinese,,0,0,0,,稍微简化的代码版本说
Dialogue: 0,0:39:05.20,0:39:09.42,English,,0,0,0,,Initialize my task queue scheduling system
Dialogue: 0,0:39:05.20,0:39:09.42,Chinese,,0,0,0,,初始化我的任务队列调度系统
Dialogue: 0,0:39:10.88,0:39:20.30,English,,0,0,0,,Create global variables of describing the beginning and end of this array to be sorted create a new task queue
Dialogue: 0,0:39:10.88,0:39:20.30,Chinese,,0,0,0,,创建描述要排序的此数组的开头和结尾的全局变量，创建一个新的任务队列
Dialogue: 0,0:39:20.82,0:39:24.14,English,,0,0,0,,And then this is the main function the tqsort helper
Dialogue: 0,0:39:20.82,0:39:24.14,Chinese,,0,0,0,,然后这是tqsort帮助器的主要功能
Dialogue: 0,0:39:25.00,0:39:31.68,English,,0,0,0,,Is given some range of addresses and a pointer to the task queue
Dialogue: 0,0:39:25.00,0:39:31.68,Chinese,,0,0,0,,给出一些范围的地址和指向任务队列的指针
Dialogue: 0,0:39:31.86,0:39:34.72,English,,0,0,0,,That's used to manage these tasks
Dialogue: 0,0:39:31.86,0:39:34.72,Chinese,,0,0,0,,那用于管理这些任务
Dialogue: 0,0:39:35.64,0:39:36.82,English,,0,0,0,,And then uh
Dialogue: 0,0:39:35.64,0:39:36.82,Chinese,,0,0,0,,然后呃
Dialogue: 0,0:39:40.38,0:39:45.44,English,,0,0,0,,When it's all day we'll just wait till all the tasks have completed this is at the top level
Dialogue: 0,0:39:40.38,0:39:45.44,Chinese,,0,0,0,,当它整天都在等待所有任务完成时，它就处于最高级别
Dialogue: 0,0:39:46.04,0:39:49.70,English,,0,0,0,,This isn't part of any recursion this is the top level code
Dialogue: 0,0:39:46.04,0:39:49.70,Chinese,,0,0,0,,这不是任何递归的一部分，这是顶级代码
Dialogue: 0,0:39:50.08,0:39:51.84,English,,0,0,0,,And then it will free up the data structures
Dialogue: 0,0:39:50.08,0:39:51.84,Chinese,,0,0,0,,然后它将释放数据结构
Dialogue: 0,0:39:54.24,0:39:58.06,English,,0,0,0,,And then this is the part of it that actually does the real work
Dialogue: 0,0:39:54.24,0:39:58.06,Chinese,,0,0,0,,然后，这是实际完成实际工作的一部分
Dialogue: 0,0:39:59.00,0:40:04.82,English,,0,0,0,,It will say so now the tqsort helper is the part
Dialogue: 0,0:39:59.00,0:40:04.82,Chinese,,0,0,0,,它会说现在tqsort助手就是这个部分
Dialogue: 0,0:40:04.94,0:40:11.62,English,,0,0,0,,That's a scientists to sort some particulars poises from
Dialogue: 0,0:40:04.94,0:40:11.62,Chinese,,0,0,0,,这是一个科学家来分析一些细节
Dialogue: 0,0:40:12.36,0:40:17.16,English,,0,0,0,,The starting address the base and some number of elements
Dialogue: 0,0:40:12.36,0:40:17.16,Chinese,,0,0,0,,起始地址是基数和一些元素
Dialogue: 0,0:40:19.06,0:40:22.12,English,,0,0,0,,And so this is what each task will do
Dialogue: 0,0:40:19.06,0:40:22.12,Chinese,,0,0,0,,所以这就是每项任务的作用
Dialogue: 0,0:40:22.46,0:40:26.68,English,,0,0,0,,And it says okay if this is a small enough block of elements
Dialogue: 0,0:40:22.46,0:40:26.68,Chinese,,0,0,0,,它说好的，如果这是一个足够小的元素块
Dialogue: 0,0:40:27.16,0:40:30.42,English,,0,0,0,,I'm just going to call my serial quicksort to do it
Dialogue: 0,0:40:27.16,0:40:30.42,Chinese,,0,0,0,,我只是打电话给我的连续快速排序来做
Dialogue: 0,0:40:31.66,0:40:34.90,English,,0,0,0,,Otherwise I'm going to
Dialogue: 0,0:40:31.66,0:40:34.90,Chinese,,0,0,0,,否则我会去
Dialogue: 0,0:40:45.44,0:40:47.24,English,,0,0,0,,Oh it's a little bit messier this okay
Dialogue: 0,0:40:45.44,0:40:47.24,Chinese,,0,0,0,,哦，这有点麻烦这没关系
Dialogue: 0,0:40:47.86,0:40:53.56,English,,0,0,0,,Now otherwise it's going to spawn a task to do the sorting
Dialogue: 0,0:40:47.86,0:40:53.56,Chinese,,0,0,0,,现在否则它将产生一个任务来进行排序
Dialogue: 0,0:40:54.04,0:40:54.80,English,,0,0,0,,Let's see
Dialogue: 0,0:40:54.04,0:40:54.80,Chinese,,0,0,0,,让我们来看看
Dialogue: 0,0:40:55.32,0:40:57.90,English,,0,0,0,,I was a little mixed up this is a high level
Dialogue: 0,0:40:55.32,0:40:57.90,Chinese,,0,0,0,,我有点混淆这是一个很高的水平
Dialogue: 0,0:40:57.90,0:41:04.22,English,,0,0,0,,So the actual splitting occurs in this thing which is where it
Dialogue: 0,0:40:57.90,0:41:04.22,Chinese,,0,0,0,,所以实际的分裂发生在这个事物的地方
Dialogue: 0,0:41:06.42,0:41:08.28,English,,0,0,0,,So this is the actual thread routine
Dialogue: 0,0:41:06.42,0:41:08.28,Chinese,,0,0,0,,所以这是实际的线程例程
Dialogue: 0,0:41:09.68,0:41:14.20,English,,0,0,0,,And what it's saying is run the partition here
Dialogue: 0,0:41:09.68,0:41:14.20,Chinese,,0,0,0,,它说的是在这里运行分区
Dialogue: 0,0:41:15.36,0:41:20.98,English,,0,0,0,,And then call this tqsort helper which you just saw on the left and the right parts
Dialogue: 0,0:41:15.36,0:41:20.98,Chinese,,0,0,0,,然后调用你刚才在左侧和右侧部分看到的tqsort助手
Dialogue: 0,0:41:25.00,0:41:31.36,English,,0,0,0,,Of it so just to review then the actual spawning of a task is done by this helper routine
Dialogue: 0,0:41:25.00,0:41:31.36,Chinese,,0,0,0,,其中只是为了回顾一下，任务的实际产生是由这个辅助程序完成的
Dialogue: 0,0:41:32.10,0:41:37.02,English,,0,0,0,,But then that what it calls is the thread routine is
Dialogue: 0,0:41:32.10,0:41:37.02,Chinese,,0,0,0,,但那就是它所谓的线程例程
Dialogue: 0,0:41:38.18,0:41:40.70,English,,0,0,0,,What does the work here and what it will do is
Dialogue: 0,0:41:38.18,0:41:40.70,Chinese,,0,0,0,,这里的工作是什么，它将做什么
Dialogue: 0,0:41:41.00,0:41:43.16,English,,0,0,0,,It will do the partitioning within that thread
Dialogue: 0,0:41:41.00,0:41:43.16,Chinese,,0,0,0,,它将在该线程内进行分区
Dialogue: 0,0:41:43.60,0:41:52.06,English,,0,0,0,,And then it will just throw back and add to the task queue two calls to this helper
Dialogue: 0,0:41:43.60,0:41:52.06,Chinese,,0,0,0,,然后它会抛出并向任务队列添加两个对此帮助程序的调用
Dialogue: 0,0:41:53.82,0:42:00.16,English,,0,0,0,,But as that kind of so between these two routines you can see it's doing this idea of a divide and conquer parallelism
Dialogue: 0,0:41:53.82,0:42:00.16,Chinese,,0,0,0,,但正如在这两个例程之间那样，你可以看到它正在实现这种分裂并征服并行性的想法
Dialogue: 0,0:42:02.00,0:42:06.12,English,,0,0,0,,So this is a performance running on the shark machines
Dialogue: 0,0:42:02.00,0:42:06.12,Chinese,,0,0,0,,所以这是在鲨鱼机器上运行的性能
Dialogue: 0,0:42:07.42,0:42:18.24,English,,0,0,0,,And this is a fairly straightforward I'm just taking some number of random value 2^37
Dialogue: 0,0:42:07.42,0:42:18.24,Chinese,,0,0,0,,这是一个相当简单的我只是采取一些随机值2 ^ 37
Dialogue: 0,0:42:22.52,0:42:23.42,English,,0,0,0,,That can't be right
Dialogue: 0,0:42:22.52,0:42:23.42,Chinese,,0,0,0,,这不可能是正确的
Dialogue: 0,0:42:25.56,0:42:29.56,English,,0,0,0,,Finish this is numbers not 2^37 right you agree with me
Dialogue: 0,0:42:25.56,0:42:29.56,Chinese,,0,0,0,,完成这是数字不是2 ^ 37你同意我
Dialogue: 0,0:42:31.04,0:42:34.28,English,,0,0,0,,2^37 is 128 billion roughly
Dialogue: 0,0:42:31.04,0:42:34.28,Chinese,,0,0,0,,2 ^ 37大约是1280亿
Dialogue: 0,0:42:34.52,0:42:37.46,English,,0,0,0,,So this number is not right I'll have to check it out
Dialogue: 0,0:42:34.52,0:42:37.46,Chinese,,0,0,0,,所以这个号码不对，我得查看一下
Dialogue: 0,0:42:39.40,0:42:43.94,English,,0,0,0,,And now what this x axis
Dialogue: 0,0:42:39.40,0:42:43.94,Chinese,,0,0,0,,而现在这个x轴是什么
Dialogue: 0,0:42:44.00,0:42:47.20,English,,0,0,0,,So the y axis just denotes how long does it take to complete
Dialogue: 0,0:42:44.00,0:42:47.20,Chinese,,0,0,0,,所以y轴只表示完成所需的时间
Dialogue: 0,0:42:47.82,0:42:52.26,English,,0,0,0,,By the way one thing if you're used to measuring performance based on CPU time
Dialogue: 0,0:42:47.82,0:42:52.26,Chinese,,0,0,0,,顺便提一下，如果你习惯于根据CPU时间测量性能
Dialogue: 0,0:42:52.92,0:42:57.52,English,,0,0,0,,That's not useful when you're talking a parallel computing you really want to talk a elapsed time
Dialogue: 0,0:42:52.92,0:42:57.52,Chinese,,0,0,0,,当你谈论并行计算时，你真的想谈谈经过的时间，那是没用的
Dialogue: 0,0:42:57.56,0:43:04.52,English,,0,0,0,,The time that you'd get from looking at a clock  and measuring it and dealing with whatever inefficiency occurs
Dialogue: 0,0:42:57.56,0:43:04.52,Chinese,,0,0,0,,从查看时钟并测量它并处理任何低效率的时间
Dialogue: 0,0:43:04.98,0:43:08.66,English,,0,0,0,,There so these are actually the elapsed run time of the entire program
Dialogue: 0,0:43:04.98,0:43:08.66,Chinese,,0,0,0,,所以这些实际上是整个程序的运行时间
Dialogue: 0,0:43:11.04,0:43:14.78,English,,0,0,0,,And you'll see that it varies according to this thing called the serial fraction
Dialogue: 0,0:43:11.04,0:43:14.78,Chinese,,0,0,0,,并且你会发现它根据称为连续分数的东西而变化
Dialogue: 0,0:43:15.54,0:43:24.64,English,,0,0,0,,The serial fraction is just at what point do I slide between a serial quicksort  or keep dividing
Dialogue: 0,0:43:15.54,0:43:24.64,Chinese,,0,0,0,,序列分数只是在串行快速排序或保持分割之间滑动的位置
Dialogue: 0,0:43:24.80,0:43:26.80,English,,0,0,0,,So how big does the array need to be
Dialogue: 0,0:43:24.80,0:43:26.80,Chinese,,0,0,0,,那么阵列需要有多大
Dialogue: 0,0:43:27.20,0:43:30.22,English,,0,0,0,,As a fraction expressed as a fraction of the original array
Dialogue: 0,0:43:27.20,0:43:30.22,Chinese,,0,0,0,,作为原始数组的一部分表示的分数
Dialogue: 0,0:43:31.52,0:43:36.04,English,,0,0,0,,Before I will go into recursion
Dialogue: 0,0:43:31.52,0:43:36.04,Chinese,,0,0,0,,在我进入递归之前
Dialogue: 0,0:43:36.14,0:43:40.06,English,,0,0,0,,If I were actually to write this a real application I wouldn't do it based on a fraction
Dialogue: 0,0:43:36.14,0:43:40.06,Chinese,,0,0,0,,如果我真的要写一个真正的应用程序，我不会基于一小部分
Dialogue: 0,0:43:40.14,0:43:47.00,English,,0,0,0,,I'd do it based on a block size to say anything smaller than a thousand elements or some number like that
Dialogue: 0,0:43:40.14,0:43:47.00,Chinese,,0,0,0,,我会根据块大小来表示任何小于千元素或类似数字的东西
Dialogue: 0,0:43:47.18,0:43:51.08,English,,0,0,0,,But this code just happens to be expressed this way
Dialogue: 0,0:43:47.18,0:43:51.08,Chinese,,0,0,0,,但是这个代码恰好以这种方式表达
Dialogue: 0,0:43:51.32,0:43:54.64,English,,0,0,0,,But the thing to notice that's interesting is you'll see here
Dialogue: 0,0:43:51.32,0:43:54.64,Chinese,,0,0,0,,但要注意的是有趣的是你会在这里看到
Dialogue: 0,0:43:57.08,0:44:01.14,English,,0,0,0,,If the fraction is 1 it basically says I won't split this at all
Dialogue: 0,0:43:57.08,0:44:01.14,Chinese,,0,0,0,,如果分数是1，它基本上说我根本不会拆分它
Dialogue: 0,0:44:01.14,0:44:04.10,English,,0,0,0,,I'm just going to call a sequential quicksort
Dialogue: 0,0:44:01.14,0:44:04.10,Chinese,,0,0,0,,我只是打电话给顺序快速排序
Dialogue: 0,0:44:04.24,0:44:07.00,English,,0,0,0,,So this is a purely sequential version of it
Dialogue: 0,0:44:04.24,0:44:07.00,Chinese,,0,0,0,,所以这是它的纯粹顺序版本
Dialogue: 0,0:44:07.56,0:44:10.80,English,,0,0,0,,And what it shows is if I once I start 2
Dialogue: 0,0:44:07.56,0:44:10.80,Chinese,,0,0,0,,它表明的是，如果我曾经开始2
Dialogue: 0,0:44:11.48,0:44:15.43,English,,0,0,0,,I'll be willing to sort of split this up and do parallelism
Dialogue: 0,0:44:11.48,0:44:15.43,Chinese,,0,0,0,,我愿意把它分开并做并行性
Dialogue: 0,0:44:15.92,0:44:18.92,English,,0,0,0,,I start making run faster and faster and faster
Dialogue: 0,0:44:15.92,0:44:18.92,Chinese,,0,0,0,,我开始更快，更快，更快地运行
Dialogue: 0,0:44:20.14,0:44:22.24,English,,0,0,0,,I'll and then I get into this trough
Dialogue: 0,0:44:20.14,0:44:22.24,Chinese,,0,0,0,,我会，然后我进入这个低谷
Dialogue: 0,0:44:22.94,0:44:27.76,English,,0,0,0,,And now if I start going finer and finer grain then I'm running into the problem
Dialogue: 0,0:44:22.94,0:44:27.76,Chinese,,0,0,0,,现在，如果我开始越来越精细，那么我就遇到了问题
Dialogue: 0,0:44:27.76,0:44:34.12,English,,0,0,0,,Where the thread overhead is more than the advantage I'm getting by doing the parallelism
Dialogue: 0,0:44:27.76,0:44:34.12,Chinese,,0,0,0,,线程开销不仅仅是我通过并行操作获得的优势
Dialogue: 0,0:44:34.26,0:44:41.54,English,,0,0,0,,And I'm faster to run that block bigger sort just use a sequential algorithm rather than parallel
Dialogue: 0,0:44:34.26,0:44:41.54,Chinese,,0,0,0,,并且我更快地运行该块更大的排序只使用顺序算法而不是并行
Dialogue: 0,0:44:43.96,0:44:47.40,English,,0,0,0,,But the good news here is this is a pretty long trough here
Dialogue: 0,0:44:43.96,0:44:47.40,Chinese,,0,0,0,,但这里的好消息是，这是一个相当长的低谷
Dialogue: 0,0:44:47.64,0:44:50.72,English,,0,0,0,,So it means is if you're trying to tune this program
Dialogue: 0,0:44:47.64,0:44:50.72,Chinese,,0,0,0,,所以这意味着如果你正在尝试调整这个程序
Dialogue: 0,0:44:51.74,0:44:57.40,English,,0,0,0,,It's not that hard you're not going to pay a huge penalty if you don't know a parameter exactly
Dialogue: 0,0:44:51.74,0:44:57.40,Chinese,,0,0,0,,如果你不完全知道参数，那么你不会付出巨大代价就不那么难了
Dialogue: 0,0:44:58.04,0:45:04.26,English,,0,0,0,,So as long as this is a huge range right 30 from a 32 to 4096
Dialogue: 0,0:44:58.04,0:45:04.26,Chinese,,0,0,0,,所以只要这是一个从32到4096的30的巨大范围
Dialogue: 0,0:45:04.28,0:45:15.34,English,,0,0,0,,It's a factor of of a lot...2^15 and 2^12,2^7 fact 128
Dialogue: 0,0:45:04.28,0:45:15.34,Chinese,,0,0,0,,这是一个很重要的因素... 2 ^ 15和2 ^ 12,2 ^ 7事实128
Dialogue: 0,0:45:16.12,0:45:19.04,English,,0,0,0,,See how I do my arithmetic and powers at 2
Dialogue: 0,0:45:16.12,0:45:19.04,Chinese,,0,0,0,,看看我如何做算术和2的力量
Dialogue: 0,0:45:19.42,0:45:27.15,English,,0,0,0,,Anyways it's roughly at you know 128 so several orders of magnitude decimal orders of magnitude over which
Dialogue: 0,0:45:19.42,0:45:27.15,Chinese,,0,0,0,,无论如何，它大致在你知道128几十个数量级的十进制数量级
Dialogue: 0,0:45:27.70,0:45:29.38,English,,0,0,0,,You get pretty comparable performance
Dialogue: 0,0:45:27.70,0:45:29.38,Chinese,,0,0,0,,你的表现相当可观
Dialogue: 0,0:45:29.54,0:45:33.88,English,,0,0,0,,So that means from a performance tuning point of view it's not that hard to do
Dialogue: 0,0:45:29.54,0:45:33.88,Chinese,,0,0,0,,所以从性能调优的角度来看，这并不难
Dialogue: 0,0:45:34.62,0:45:37.78,English,,0,0,0,,And you also see we're getting a pretty decent speed up
Dialogue: 0,0:45:34.62,0:45:37.78,Chinese,,0,0,0,,而且你也看到我们的速度相当不错
Dialogue: 0,0:45:38.72,0:45:41.74,English,,0,0,0,,On our eight core to a hyper-threaded machine
Dialogue: 0,0:45:38.72,0:45:41.74,Chinese,,0,0,0,,在我们的八核到超线程机器上
Dialogue: 0,0:45:41.80,0:45:44.80,English,,0,0,0,,We're getting up basically out 7x performance
Dialogue: 0,0:45:41.80,0:45:44.80,Chinese,,0,0,0,,我们的性能基本上达到了7倍
Dialogue: 0,0:45:45.62,0:45:50.60,English,,0,0,0,,And hyper-threading really isn't helping us at all is part of the lesson here
Dialogue: 0,0:45:45.62,0:45:50.60,Chinese,,0,0,0,,超线程实际上并没有帮助我们这里的课程的一部分
Dialogue: 0,0:45:51.24,0:45:53.86,English,,0,0,0,,But if you just think of it as eight cores then that's pretty good
Dialogue: 0,0:45:51.24,0:45:53.86,Chinese,,0,0,0,,但如果你只把它想象成八个核心，那就非常好了
Dialogue: 0,0:45:59.28,0:46:05.78,English,,0,0,0,,So there is an obvious place here where there's Amdahl law issue going on
Dialogue: 0,0:45:59.28,0:46:05.78,Chinese,,0,0,0,,所以这里有一个显而易见的地方，那就是Amdahl法律问题正在进行中
Dialogue: 0,0:46:05.80,0:46:08.26,English,,0,0,0,,If you think at that first top-level split
Dialogue: 0,0:46:05.80,0:46:08.26,Chinese,,0,0,0,,如果你想到第一个顶级分裂
Dialogue: 0,0:46:09.32,0:46:14.66,English,,0,0,0,,The first call to partition is being done over the entire ray by a serial sequential process
Dialogue: 0,0:46:09.32,0:46:14.66,Chinese,,0,0,0,,第一次分区调用是通过串行顺序进程在整个光线上完成的
Dialogue: 0,0:46:15.60,0:46:16.50,English,,0,0,0,,Right that
Dialogue: 0,0:46:15.60,0:46:16.50,Chinese,,0,0,0,,对，那
Dialogue: 0,0:46:16.82,0:46:24.38,English,,0,0,0,,So at the very least that is not going parallel at all there's going exactly one thread is doing the initial partition
Dialogue: 0,0:46:16.82,0:46:24.38,Chinese,,0,0,0,,因此，至少根本没有并行，只有一个线程正在进行初始分区
Dialogue: 0,0:46:25.72,0:46:30.64,English,,0,0,0,,And then that splits into two so at most you have two threads worth of parallelism
Dialogue: 0,0:46:25.72,0:46:30.64,Chinese,,0,0,0,,然后分成两个，所以最多你有两个并行的线程
Dialogue: 0,0:46:31.24,0:46:33.38,English,,0,0,0,,And then the next level down at most four
Dialogue: 0,0:46:31.24,0:46:33.38,Chinese,,0,0,0,,然后下一级最多下降四级
Dialogue: 0,0:46:33.42,0:46:37.48,English,,0,0,0,,And so you really don't you have to get several levels of recursion down
Dialogue: 0,0:46:33.42,0:46:37.48,Chinese,,0,0,0,,所以你真的不需要进行几级递归
Dialogue: 0,0:46:38.00,0:46:41.42,English,,0,0,0,,Before you're really running on all the course that you have available
Dialogue: 0,0:46:38.00,0:46:41.42,Chinese,,0,0,0,,在你真正运行所有可用的课程之前
Dialogue: 0,0:46:41.70,0:46:45.06,English,,0,0,0,,So you'd think that that's limiting your speed up and
Dialogue: 0,0:46:41.70,0:46:45.06,Chinese,,0,0,0,,所以你认为这限制了你的速度和
Dialogue: 0,0:46:45.06,0:46:49.22,English,,0,0,0,,It does and that's part of the reason why our best performance is
Dialogue: 0,0:46:45.06,0:46:49.22,Chinese,,0,0,0,,这确实是我们最佳表现的部分原因
Dialogue: 0,0:46:50.98,0:46:53.32,English,,0,0,0,,A factor of seven and not a factor of eight or more
Dialogue: 0,0:46:50.98,0:46:53.32,Chinese,,0,0,0,,七分之一而不是八分之一或更多
Dialogue: 0,0:46:59.10,0:47:09.30,English,,0,0,0,,So there's quite a bit of work as  mentioned on how to speed up performance including how to make quicksort go faster
Dialogue: 0,0:46:59.10,0:47:09.30,Chinese,,0,0,0,,因此，关于如何加快性能，包括如何使快速排序更快，提到了相当多的工作
Dialogue: 0,0:47:12.00,0:47:15.62,English,,0,0,0,,So there's a vast body of literature on parallel sort
Dialogue: 0,0:47:12.00,0:47:15.62,Chinese,,0,0,0,,因此，有大量关于并行排序的文献
Dialogue: 0,0:47:19.92,0:47:24.88,English,,0,0,0,,So one thing I tried was to say okay well let's try and do this partitioning
Dialogue: 0,0:47:19.92,0:47:24.88,Chinese,,0,0,0,,所以我试过的一件事就是说好吧让我们尝试做这个分区
Dialogue: 0,0:47:27.94,0:47:32.70,English,,0,0,0,,Step they least the top couple levels let's try and do a parallel version of that and
Dialogue: 0,0:47:27.94,0:47:32.70,Chinese,,0,0,0,,步骤他们最少的顶级夫妇级别让我们试着做一个并行版本
Dialogue: 0,0:47:33.34,0:47:36.16,English,,0,0,0,,So the idea is you pick one pivot element
Dialogue: 0,0:47:33.34,0:47:36.16,Chinese,,0,0,0,,所以你的想法就是选择一个枢轴元素
Dialogue: 0,0:47:36.38,0:47:39.24,English,,0,0,0,,But now you fire in this example for threads
Dialogue: 0,0:47:36.38,0:47:39.24,Chinese,,0,0,0,,但现在你在这个例子中为线程开火
Dialogue: 0,0:47:40.42,0:47:47.18,English,,0,0,0,,And each of those four threads runs a partition step on one-fourth of the range
Dialogue: 0,0:47:40.42,0:47:47.18,Chinese,,0,0,0,,并且这四个线程中的每一个都在该范围的四分之一上运行分区步骤
Dialogue: 0,0:47:48.26,0:47:51.12,English,,0,0,0,,And it don't generate their own versions of left and right
Dialogue: 0,0:47:48.26,0:47:51.12,Chinese,,0,0,0,,并且它不会生成左右自己的版本
Dialogue: 0,0:47:52.26,0:47:59.12,English,,0,0,0,,And then you globally figure out how many are in each of these sub ranges
Dialogue: 0,0:47:52.26,0:47:59.12,Chinese,,0,0,0,,然后你全局计算每个子范围中有多少个
Dialogue: 0,0:48:00.46,0:48:07.00,English,,0,0,0,,And then you tell each thread okay now you copy your part of it over to the relevant section of the array
Dialogue: 0,0:48:00.46,0:48:07.00,Chinese,,0,0,0,,然后你告诉每个线程好了，现在你将它的一部分复制到数组的相关部分
Dialogue: 0,0:48:09.60,0:48:13.78,English,,0,0,0,,But the good news so there's some amount of synchronization that goes on there
Dialogue: 0,0:48:09.60,0:48:13.78,Chinese,,0,0,0,,但好消息是那里有一些同步
Dialogue: 0,0:48:14.48,0:48:18.14,English,,0,0,0,,But you can imagine that this partitioning step
Dialogue: 0,0:48:14.48,0:48:18.14,Chinese,,0,0,0,,但你可以想象这个分区步骤
Dialogue: 0,0:48:18.44,0:48:23.78,English,,0,0,0,,Once when you're running it is completely independent of across the different threads
Dialogue: 0,0:48:18.44,0:48:23.78,Chinese,,0,0,0,,一旦你运行它就完全独立于不同的线程
Dialogue: 0,0:48:23.82,0:48:26.52,English,,0,0,0,,So it's getting a almost ideal speed-up
Dialogue: 0,0:48:23.82,0:48:26.52,Chinese,,0,0,0,,所以它获得了几乎理想的加速
Dialogue: 0,0:48:27.62,0:48:32.90,English,,0,0,0,,So I implemented this and tried and I couldn't make it run faster than the original code
Dialogue: 0,0:48:27.62,0:48:32.90,Chinese,,0,0,0,,所以我实现了这个并尝试了，我无法让它比原始代码运行得更快
Dialogue: 0,0:48:33.72,0:48:39.68,English,,0,0,0,,And I think the the problem with this was the copying the cost of copying data
Dialogue: 0,0:48:33.72,0:48:39.68,Chinese,,0,0,0,,我认为这个问题是复制数据的复制成本
Dialogue: 0,0:48:41.96,0:48:47.80,English,,0,0,0,,Here was even though it's being done by multiple threads
Dialogue: 0,0:48:41.96,0:48:47.80,Chinese,,0,0,0,,即使它是由多个线程完成的
Dialogue: 0,0:48:48.30,0:48:51.24,English,,0,0,0,,And getting pretty good performance out of the memory system
Dialogue: 0,0:48:48.30,0:48:51.24,Chinese,,0,0,0,,从内存系统中获得相当不错的性能
Dialogue: 0,0:48:51.26,0:48:56.12,English,,0,0,0,,Because you're doing sequential you know all the cache issues are pretty good here
Dialogue: 0,0:48:51.26,0:48:56.12,Chinese,,0,0,0,,因为你正在执行顺序操作，所以你知道所有缓存问题都非常好
Dialogue: 0,0:48:56.80,0:48:58.94,English,,0,0,0,,But that's just enough extra work
Dialogue: 0,0:48:56.80,0:48:58.94,Chinese,,0,0,0,,但那只是额外的工作
Dialogue: 0,0:48:59.52,0:49:02.54,English,,0,0,0,,That has to be done for this parallel code that doesn't have to be done
Dialogue: 0,0:48:59.52,0:49:02.54,Chinese,,0,0,0,,必须为这个不必完成的并行代码完成
Dialogue: 0,0:49:02.86,0:49:04.88,English,,0,0,0,,The sequential code is totally in place
Dialogue: 0,0:49:02.86,0:49:04.88,Chinese,,0,0,0,,顺序代码完全到位
Dialogue: 0,0:49:05.82,0:49:08.96,English,,0,0,0,,Meaning not using any additional storage not copying
Dialogue: 0,0:49:05.82,0:49:08.96,Chinese,,0,0,0,,意思是不使用任何其他存储而不是复制
Dialogue: 0,0:49:09.34,0:49:13.12,English,,0,0,0,,And so that's just enough of a penalty on the parallel part
Dialogue: 0,0:49:09.34,0:49:13.12,Chinese,,0,0,0,,所以这对平行部分来说就足够了
Dialogue: 0,0:49:13.56,0:49:16.04,English,,0,0,0,,That it didn't really improve performance at all
Dialogue: 0,0:49:13.56,0:49:16.04,Chinese,,0,0,0,,它根本没有真正提高性能
Dialogue: 0,0:49:16.56,0:49:20.54,English,,0,0,0,,So that code is shown as part of the code on the course website
Dialogue: 0,0:49:16.56,0:49:20.54,Chinese,,0,0,0,,因此，该代码显示为课程网站上代码的一部分
Dialogue: 0,0:49:20.68,0:49:25.70,English,,0,0,0,,But like I said I banged on it quite a bit and trying to tune it
Dialogue: 0,0:49:20.68,0:49:25.70,Chinese,,0,0,0,,但就像我说的那样，我对它进行了很大的攻击并试图调整它
Dialogue: 0,0:49:25.82,0:49:27.90,English,,0,0,0,,And squeak it in various ways and could never make it
Dialogue: 0,0:49:25.82,0:49:27.90,Chinese,,0,0,0,,并以各种方式吱吱作响，永远无法成功
Dialogue: 0,0:49:28.46,0:49:31.54,English,,0,0,0,,So I got better overall performance out of this program
Dialogue: 0,0:49:28.46,0:49:31.54,Chinese,,0,0,0,,所以我从这个项目中获得了更好的整体表现
Dialogue: 0,0:49:33.34,0:49:38.70,English,,0,0,0,,And so that's again a lesson and that's one of the unfortunate lessons is you can spend a lot of time
Dialogue: 0,0:49:33.34,0:49:38.70,Chinese,,0,0,0,,所以这又是一个教训，这是一个不幸的教训，你可以花很多时间
Dialogue: 0,0:49:40.16,0:49:43.64,English,,0,0,0,,Trying to make a program run faster and get absolutely nowhere
Dialogue: 0,0:49:40.16,0:49:43.64,Chinese,,0,0,0,,试图让程序运行得更快，绝对无处可去
Dialogue: 0,0:49:44.72,0:49:47.34,English,,0,0,0,,And it's frustrating because you put in a lot of work
Dialogue: 0,0:49:44.72,0:49:47.34,Chinese,,0,0,0,,这令人沮丧，因为你投入了大量的工作
Dialogue: 0,0:49:47.90,0:49:52.72,English,,0,0,0,,And you know it's a pretty cool idea and you'd love to publish a paper about it or tell your friends about it
Dialogue: 0,0:49:47.90,0:49:52.72,Chinese,,0,0,0,,而且你知道这是一个非常酷的想法，你喜欢发表一篇关于它的论文或者告诉你的朋友
Dialogue: 0,0:49:53.02,0:49:55.64,English,,0,0,0,,And it just goes nowhere and it just sits there
Dialogue: 0,0:49:53.02,0:49:55.64,Chinese,,0,0,0,,它只是无处可去，只是坐在那里
Dialogue: 0,0:49:55.98,0:50:02.20,English,,0,0,0,,There's nothing unfortunately there's not an accumulated repository of the bad ideas of computer science
Dialogue: 0,0:49:55.98,0:50:02.20,Chinese,,0,0,0,,遗憾的是，没有一个积累的计算机科学坏思想库
Dialogue: 0,0:50:02.30,0:50:03.70,English,,0,0,0,,Don't waste your time trying this
Dialogue: 0,0:50:02.30,0:50:03.70,Chinese,,0,0,0,,不要浪费你的时间尝试这个
Dialogue: 0,0:50:04.30,0:50:06.30,English,,0,0,0,,That people can talk about so
Dialogue: 0,0:50:04.30,0:50:06.30,Chinese,,0,0,0,,人们可以这么说
Dialogue: 0,0:50:06.88,0:50:09.18,English,,0,0,0,,This is just a lesson to learn
Dialogue: 0,0:50:06.88,0:50:09.18,Chinese,,0,0,0,,这只是一个值得学习的课程
Dialogue: 0,0:50:11.90,0:50:15.34,English,,0,0,0,,So anyways that was my experience with that
Dialogue: 0,0:50:11.90,0:50:15.34,Chinese,,0,0,0,,所以无论如何这是我的经验
Dialogue: 0,0:50:15.64,0:50:21.78,English,,0,0,0,,Again other people have spent a lot more time this is one of the most common applications
Dialogue: 0,0:50:15.64,0:50:21.78,Chinese,,0,0,0,,其他人花了很多时间这是最常见的应用程序之一
Dialogue: 0,0:50:22.10,0:50:24.52,English,,0,0,0,,That people try to do parallel programming for
Dialogue: 0,0:50:22.10,0:50:24.52,Chinese,,0,0,0,,人们试图做并行编程
Dialogue: 0,0:50:26.68,0:50:30.78,English,,0,0,0,,So some of the lessons from this is you need a good strategy
Dialogue: 0,0:50:26.68,0:50:30.78,Chinese,,0,0,0,,因此，一些教训是你需要一个好的策略
Dialogue: 0,0:50:30.80,0:50:33.42,English,,0,0,0,,For how you're going to get parallelism out of your application
Dialogue: 0,0:50:30.80,0:50:33.42,Chinese,,0,0,0,,了解如何从应用程序中获得并行性
Dialogue: 0,0:50:34.10,0:50:38.94,English,,0,0,0,,And I showed you two basic versions one is partitioned into k parts
Dialogue: 0,0:50:34.10,0:50:38.94,Chinese,,0,0,0,,我向你展示了两个基本版本，一个被划分为k个部分
Dialogue: 0,0:50:39.00,0:50:42.26,English,,0,0,0,,They're more or less completely independent of each other
Dialogue: 0,0:50:39.00,0:50:42.26,Chinese,,0,0,0,,它们或多或少完全相互独立
Dialogue: 0,0:50:42.78,0:50:46.78,English,,0,0,0,,Or something like a divide and conquer strategy where you can keep splitting it
Dialogue: 0,0:50:42.78,0:50:46.78,Chinese,,0,0,0,,或者类似于分而治之的战略，你可以继续分裂它
Dialogue: 0,0:50:46.90,0:50:50.92,English,,0,0,0,,But the two splits that you create out of that can go concurrently
Dialogue: 0,0:50:46.90,0:50:50.92,Chinese,,0,0,0,,但是你创建的两个分裂可以同时进行
Dialogue: 0,0:50:51.78,0:50:54.98,English,,0,0,0,,These other different types of parallelism to
Dialogue: 0,0:50:51.78,0:50:54.98,Chinese,,0,0,0,,这些其他不同类型的并行性
Dialogue: 0,0:50:55.60,0:51:00.06,English,,0,0,0,,In general you want to make the inner loops you can't have any synchronization primitives
Dialogue: 0,0:50:55.60,0:51:00.06,Chinese,,0,0,0,,通常，你希望使内部循环不能具有任何同步原语
Dialogue: 0,0:51:00.60,0:51:02.56,English,,0,0,0,,In there it will just run too slow
Dialogue: 0,0:51:00.60,0:51:02.56,Chinese,,0,0,0,,在那里它会运行得太慢
Dialogue: 0,0:51:03.28,0:51:07.90,English,,0,0,0,,Amdahl as I mentioned is always sort of lurking in the background of
Dialogue: 0,0:51:03.28,0:51:07.90,Chinese,,0,0,0,,我提到的Amdahl总是潜伏在背景中
Dialogue: 0,0:51:08.00,0:51:13.36,English,,0,0,0,,If you can always feed up a part of your program then the other part will become the bottleneck
Dialogue: 0,0:51:08.00,0:51:13.36,Chinese,,0,0,0,,如果你总是可以提供程序的一部分，那么另一部分将成为瓶颈
Dialogue: 0,0:51:14.26,0:51:17.81,English,,0,0,0,,But the other thing is like I said you can do it
Dialogue: 0,0:51:14.26,0:51:17.81,Chinese,,0,0,0,,但另一件事就是我说你可以做到
Dialogue: 0,0:51:17.81,0:51:22.50,English,,0,0,0,,You've got the tools you've learned with p threads
Dialogue: 0,0:51:17.81,0:51:22.50,Chinese,,0,0,0,,你已经掌握了用p线程学到的工具
Dialogue: 0,0:51:22.92,0:51:27.22,English,,0,0,0,,And your knowledge of programming and your understanding of cache memories and things like that
Dialogue: 0,0:51:22.92,0:51:27.22,Chinese,,0,0,0,,以及你对编程的理解以及对缓存和类似事物的理解
Dialogue: 0,0:51:27.74,0:51:32.80,English,,0,0,0,,You've got the tools you need to be an effective programmer of this kind of thing
Dialogue: 0,0:51:27.74,0:51:32.80,Chinese,,0,0,0,,你已经拥有了成为这类事物的有效程序员所需的工具
Dialogue: 0,0:51:33.94,0:51:41.36,English,,0,0,0,,But you have to and there's nothing that beats sort of trial and error and testing and tuning experimenting
Dialogue: 0,0:51:33.94,0:51:41.36,Chinese,,0,0,0,,但是你必须要而且没有什么比试验和错误以及测试和调试实验更好的了
Dialogue: 0,0:51:41.78,0:51:44.16,English,,0,0,0,,If there's some parameters that need to be set
Dialogue: 0,0:51:41.78,0:51:44.16,Chinese,,0,0,0,,如果有一些参数需要设置
Dialogue: 0,0:51:44.32,0:51:48.28,English,,0,0,0,,Then you want to run experiments will sweep through the parameters to try and figure out
Dialogue: 0,0:51:44.32,0:51:48.28,Chinese,,0,0,0,,然后你想运行实验将扫描参数来试图弄清楚
Dialogue: 0,0:51:48.88,0:51:50.14,English,,0,0,0,,What the setting should be
Dialogue: 0,0:51:48.88,0:51:50.14,Chinese,,0,0,0,,设置应该是什么
Dialogue: 0,0:51:52.08,0:51:54.76,English,,0,0,0,,So that's sort of a little bit about parallel programming
Dialogue: 0,0:51:52.08,0:51:54.76,Chinese,,0,0,0,,这就是并行编程的一点点
Dialogue: 0,0:51:55.16,0:52:01.50,English,,0,0,0,,Let me just finish this lecture with a little bit of sort of classic issues about concurrency
Dialogue: 0,0:51:55.16,0:52:01.50,Chinese,,0,0,0,,让我在本讲座中完成一些关于并发性的经典问题
Dialogue: 0,0:52:01.62,0:52:05.32,English,,0,0,0,,That that are critical when you're dealing with
Dialogue: 0,0:52:01.62,0:52:05.32,Chinese,,0,0,0,,当你处理时，那是至关重要的
Dialogue: 0,0:52:06.50,0:52:11.14,English,,0,0,0,,These systems based on what you call a shared memory model of computation
Dialogue: 0,0:52:06.50,0:52:11.14,Chinese,,0,0,0,,这些系统基于你所谓的共享内存计算模型
Dialogue: 0,0:52:11.76,0:52:18.00,English,,0,0,0,,So multi-core is an example of conceptually multi-threaded computation remember
Dialogue: 0,0:52:11.76,0:52:18.00,Chinese,,0,0,0,,因此，多核是概念上多线程计算的一个例子
Dialogue: 0,0:52:18.02,0:52:21.38,English,,0,0,0,,You're working within a single virtual address space
Dialogue: 0,0:52:18.02,0:52:21.38,Chinese,,0,0,0,,你正在一个虚拟地址空间内工作
Dialogue: 0,0:52:22.48,0:52:24.68,English,,0,0,0,,And you have private stacks
Dialogue: 0,0:52:22.48,0:52:24.68,Chinese,,0,0,0,,你有私人堆栈
Dialogue: 0,0:52:25.18,0:52:30.26,English,,0,0,0,,But the more global the heap memory is completely shared across threads
Dialogue: 0,0:52:25.18,0:52:30.26,Chinese,,0,0,0,,但是，堆内存在线程之间完全共享的全局性越大
Dialogue: 0,0:52:31.04,0:52:35.06,English,,0,0,0,,And so that's what you call the shared memory programming model
Dialogue: 0,0:52:31.04,0:52:35.06,Chinese,,0,0,0,,这就是你所说的共享内存编程模型
Dialogue: 0,0:52:35.18,0:52:36.88,English,,0,0,0,,And that's what we've really been looking at this course
Dialogue: 0,0:52:35.18,0:52:36.88,Chinese,,0,0,0,,这就是我们真正关注的课程
Dialogue: 0,0:52:38.76,0:52:42.97,English,,0,0,0,,So there's a certain interesting question about called memory consistency models
Dialogue: 0,0:52:38.76,0:52:42.97,Chinese,,0,0,0,,因此，有一个关于被称为内存一致性模型的有趣问题
Dialogue: 0,0:52:43.94,0:52:46.58,English,,0,0,0,,And here I'll illustrate it with a very simple example
Dialogue: 0,0:52:43.94,0:52:46.58,Chinese,,0,0,0,,在这里，我将用一个非常简单的例子来说明它
Dialogue: 0,0:52:47.12,0:52:50.78,English,,0,0,0,,Imagine we have two global variables a and b
Dialogue: 0,0:52:47.12,0:52:50.78,Chinese,,0,0,0,,想象一下，我们有两个全局变量a和b
Dialogue: 0,0:52:51.02,0:52:52.22,English,,0,0,0,,And we have two different threads
Dialogue: 0,0:52:51.02,0:52:52.22,Chinese,,0,0,0,,我们有两个不同的主题
Dialogue: 0,0:52:53.08,0:52:58.66,English,,0,0,0,,And so the first thread is going to write meaning assign a value to a
Dialogue: 0,0:52:53.08,0:52:58.66,Chinese,,0,0,0,,所以第一个线程将写入含义为a赋值
Dialogue: 0,0:52:59.12,0:53:02.02,English,,0,0,0,,And it's going to read meaning print the value of b
Dialogue: 0,0:52:59.12,0:53:02.02,Chinese,,0,0,0,,并且它将读取意义打印b的值
Dialogue: 0,0:53:02.72,0:53:08.84,English,,0,0,0,,And the other thread is going to do the opposite it's going to write assigned a value to b and print the value of a
Dialogue: 0,0:53:02.72,0:53:08.84,Chinese,,0,0,0,,另一个线程将执行相反的操作，它将为b分配一个值并打印a的值
Dialogue: 0,0:53:09.40,0:53:14.20,English,,0,0,0,,And so now the question is what are the possible outputs for this program
Dialogue: 0,0:53:09.40,0:53:14.20,Chinese,,0,0,0,,所以现在的问题是该计划的可能产出是什么
Dialogue: 0,0:53:15.52,0:53:21.12,English,,0,0,0,,And so there's a model that sort of the accepted standard called sequential consistency
Dialogue: 0,0:53:15.52,0:53:21.12,Chinese,,0,0,0,,因此，有一种模型可以接受称为顺序一致性的标准
Dialogue: 0,0:53:21.64,0:53:24.22,English,,0,0,0,,Which means that these events can occur
Dialogue: 0,0:53:21.64,0:53:24.22,Chinese,,0,0,0,,这意味着可以发生这些事件
Dialogue: 0,0:53:24.68,0:53:33.56,English,,0,0,0,,Well that these that within a single thread things have to occur in the sequential order of that thread
Dialogue: 0,0:53:24.68,0:53:33.56,Chinese,,0,0,0,,那些在单个线程中的东西必须按照该线程的顺序发生
Dialogue: 0,0:53:34.52,0:53:40.98,English,,0,0,0,,But across threads whether write a write b occurs first is completely arbitrary
Dialogue: 0,0:53:34.52,0:53:40.98,Chinese,,0,0,0,,但是跨线程是否先写入写入b是完全随意的
Dialogue: 0,0:53:41.30,0:53:43.80,English,,0,0,0,,And similarly whether writing of b occurs
Dialogue: 0,0:53:41.30,0:53:43.80,Chinese,,0,0,0,,并且类似地是否发生b的写入
Dialogue: 0,0:53:44.56,0:53:52.20,English,,0,0,0,,Between these two actions or before is all too arbitrary
Dialogue: 0,0:53:44.56,0:53:52.20,Chinese,,0,0,0,,在这两个行动之间或以前的行动都太随意了
Dialogue: 0,0:53:52.28,0:53:56.68,English,,0,0,0,,So what it means is you can take two different threads
Dialogue: 0,0:53:52.28,0:53:56.68,Chinese,,0,0,0,,所以这意味着你可以采取两种不同的线程
Dialogue: 0,0:53:56.70,0:54:01.56,English,,0,0,0,,And you can interleave their events in anyway
Dialogue: 0,0:53:56.70,0:54:01.56,Chinese,,0,0,0,,无论如何，你可以交错他们的事件
Dialogue: 0,0:54:02.26,0:54:06.90,English,,0,0,0,,But you should be able to pull out of that interleaving
Dialogue: 0,0:54:02.26,0:54:06.90,Chinese,,0,0,0,,但是你应该能够摆脱那种交错
Dialogue: 0,0:54:07.44,0:54:10.98,English,,0,0,0,,The sequential order of either of both of the two threads
Dialogue: 0,0:54:07.44,0:54:10.98,Chinese,,0,0,0,,两个线程中任何一个的顺序
Dialogue: 0,0:54:12.48,0:54:16.54,English,,0,0,0,,So when you do that you end up you can enumerate in the example like this
Dialogue: 0,0:54:12.48,0:54:16.54,Chinese,,0,0,0,,因此，当你这样做时，你最终可以在这样的例子中枚举
Dialogue: 0,0:54:17.00,0:54:19.26,English,,0,0,0,,All the possibilities you can say well look it
Dialogue: 0,0:54:17.00,0:54:19.26,Chinese,,0,0,0,,你可以说很好看的所有可能性
Dialogue: 0,0:54:20.12,0:54:22.48,English,,0,0,0,,First is either going to be right a or right b
Dialogue: 0,0:54:20.12,0:54:22.48,Chinese,,0,0,0,,首先要么是正确的，要么是正确的b
Dialogue: 0,0:54:23.40,0:54:24.60,English,,0,0,0,,Let's pick right a
Dialogue: 0,0:54:23.40,0:54:24.60,Chinese,,0,0,0,,让我们选择一个
Dialogue: 0,0:54:25.42,0:54:30.04,English,,0,0,0,,So now the next event will be either a read of b or write of b
Dialogue: 0,0:54:25.42,0:54:30.04,Chinese,,0,0,0,,所以现在下一个事件将是读取b或写入b
Dialogue: 0,0:54:31.86,0:54:36.10,English,,0,0,0,,And then if I do write a write read b
Dialogue: 0,0:54:31.86,0:54:36.10,Chinese,,0,0,0,,如果我写了一个写入读取b
Dialogue: 0,0:54:36.78,0:54:38.42,English,,0,0,0,,Then I've completed this thread
Dialogue: 0,0:54:36.78,0:54:38.42,Chinese,,0,0,0,,然后我完成了这个帖子
Dialogue: 0,0:54:39.04,0:54:44.44,English,,0,0,0,,And so now the only possibility is to write to b and read a and so forth
Dialogue: 0,0:54:39.04,0:54:44.44,Chinese,,0,0,0,,所以现在唯一的可能性是写入b并读取等等
Dialogue: 0,0:54:44.52,0:54:48.74,English,,0,0,0,,You work out all the possible things you get six different event orderings
Dialogue: 0,0:54:44.52,0:54:48.74,Chinese,,0,0,0,,你可以计算出六种不同的事件顺序
Dialogue: 0,0:54:49.52,0:54:55.46,English,,0,0,0,,And then what will be printed is well first of all whether you print before a
Dialogue: 0,0:54:49.52,0:54:55.46,Chinese,,0,0,0,,然后，无论你是在打印之前打印，首先要打印的是什么
Dialogue: 0,0:54:56.02,0:54:59.42,English,,0,0,0,,Would depend on the relative ordering of those two threads
Dialogue: 0,0:54:56.02,0:54:59.42,Chinese,,0,0,0,,将取决于这两个线程的相对顺序
Dialogue: 0,0:54:59.42,0:55:02.34,English,,0,0,0,,So that's shown I'm showing the b value in blue
Dialogue: 0,0:54:59.42,0:55:02.34,Chinese,,0,0,0,,所以我看到我用蓝色显示b值
Dialogue: 0,0:55:03.06,0:55:07.54,English,,0,0,0,,And the red value in red I'm sorry the a value in red
Dialogue: 0,0:55:03.06,0:55:07.54,Chinese,,0,0,0,,红色的红色值我很抱歉红色的值
Dialogue: 0,0:55:09.02,0:55:10.46,English,,0,0,0,,And you'll get these different
Dialogue: 0,0:55:09.02,0:55:10.46,Chinese,,0,0,0,,你会得到这些不同的东西
Dialogue: 0,0:55:11.28,0:55:14.88,English,,0,0,0,,Possibilities these are all the six possible outputs of this program
Dialogue: 0,0:55:11.28,0:55:14.88,Chinese,,0,0,0,,可能性这些都是该计划的六个可能输出
Dialogue: 0,0:55:15.54,0:55:22.88,English,,0,0,0,,But you'll see that there are two other outputs one could imagine that won't arise
Dialogue: 0,0:55:15.54,0:55:22.88,Chinese,,0,0,0,,但是你会发现有两个可以想象的其他输出不会出现
Dialogue: 0,0:55:23.78,0:55:30.48,English,,0,0,0,,One is to print 101 in other words to have them both print
Dialogue: 0,0:55:23.78,0:55:30.48,Chinese,,0,0,0,,换句话说，就是打印101以使它们都打印
Dialogue: 0,0:55:31.64,0:55:34.28,English,,0,0,0,,The original values of these two variables
Dialogue: 0,0:55:31.64,0:55:34.28,Chinese,,0,0,0,,这两个变量的原始值
Dialogue: 0,0:55:34.88,0:55:36.62,English,,0,0,0,,And that's impossible because
Dialogue: 0,0:55:34.88,0:55:36.62,Chinese,,0,0,0,,这是不可能的，因为
Dialogue: 0,0:55:37.74,0:55:39.86,English,,0,0,0,,I have to have done at least one right
Dialogue: 0,0:55:37.74,0:55:39.86,Chinese,,0,0,0,,我必须至少完成一项权利
Dialogue: 0,0:55:42.26,0:55:45.84,English,,0,0,0,,Before I can reach either of these two print statements right
Dialogue: 0,0:55:42.26,0:55:45.84,Chinese,,0,0,0,,在我能够正确地达到这两个印刷语句之前
Dialogue: 0,0:55:46.28,0:55:50.44,English,,0,0,0,,So it's not possible for these to still be in their original values of
Dialogue: 0,0:55:46.28,0:55:50.44,Chinese,,0,0,0,,所以这些仍然不可能仍然是他们原来的价值观
Dialogue: 0,0:55:51.70,0:55:53.62,English,,0,0,0,,When I hit these print statements
Dialogue: 0,0:55:51.70,0:55:53.62,Chinese,,0,0,0,,当我点击这些打印语句时
Dialogue: 0,0:55:56.14,0:56:01.06,English,,0,0,0,,And whichever order I hit these two,so those two are impossible
Dialogue: 0,0:55:56.14,0:56:01.06,Chinese,,0,0,0,,无论我击中这两个顺序，所以这两个是不可能的
Dialogue: 0,0:56:01.36,0:56:04.48,English,,0,0,0,,So that's the idea of sequential consistency that there's
Dialogue: 0,0:56:01.36,0:56:04.48,Chinese,,0,0,0,,所以这就是顺序一致性的想法
Dialogue: 0,0:56:05.16,0:56:10.96,English,,0,0,0,,Some very large number but of possible outputs of a program
Dialogue: 0,0:56:05.16,0:56:10.96,Chinese,,0,0,0,,一些非常大的但可能的程序输出
Dialogue: 0,0:56:11.42,0:56:14.40,English,,0,0,0,,But in any case they can't violate
Dialogue: 0,0:56:11.42,0:56:14.40,Chinese,,0,0,0,,但无论如何他们都不能违反
Dialogue: 0,0:56:14.86,0:56:17.26,English,,0,0,0,,The ordering implied by the individual threads
Dialogue: 0,0:56:14.86,0:56:17.26,Chinese,,0,0,0,,各个线程隐含的顺序
Dialogue: 0,0:56:19.44,0:56:23.36,English,,0,0,0,,So you'd say okay that seems like pretty obvious thing
Dialogue: 0,0:56:19.44,0:56:23.36,Chinese,,0,0,0,,所以你说好的，这看起来很明显
Dialogue: 0,0:56:24.66,0:56:29.16,English,,0,0,0,,But actually if you think from a hardware perspective it's not that trivial to make that happen
Dialogue: 0,0:56:24.66,0:56:29.16,Chinese,,0,0,0,,但实际上，如果你从硬件的角度思考，实现这一目标并非易事
Dialogue: 0,0:56:30.04,0:56:36.04,English,,0,0,0,,So let me just throw a show you a scenario of multi-core hardware
Dialogue: 0,0:56:30.04,0:56:36.04,Chinese,,0,0,0,,所以，让我向你展示一个多核硬件的场景
Dialogue: 0,0:56:36.58,0:56:38.70,English,,0,0,0,,That would violate sequential consistency
Dialogue: 0,0:56:36.58,0:56:38.70,Chinese,,0,0,0,,这会违反顺序一致性
Dialogue: 0,0:56:39.72,0:56:42.98,English,,0,0,0,,Assume that each of our threads has its own private cache
Dialogue: 0,0:56:39.72,0:56:42.98,Chinese,,0,0,0,,假设我们的每个线程都有自己的私有缓存
Dialogue: 0,0:56:44.68,0:56:49.74,English,,0,0,0,,And so if I execute this statement
Dialogue: 0,0:56:44.68,0:56:49.74,Chinese,,0,0,0,,所以如果我执行这个声明
Dialogue: 0,0:56:50.14,0:56:57.26,English,,0,0,0,,What I'll do is I will grab a copy of a from the main memory and bring it into my cache
Dialogue: 0,0:56:50.14,0:56:57.26,Chinese,,0,0,0,,我要做的是我将从主内存中获取一份副本并将其带入我的缓存中
Dialogue: 0,0:56:57.82,0:56:59.92,English,,0,0,0,,And I will assign this new value to it
Dialogue: 0,0:56:57.82,0:56:59.92,Chinese,,0,0,0,,我会将这个新值分配给它
Dialogue: 0,0:57:00.96,0:57:08.20,English,,0,0,0,,And similarly a thread to will grab a copy of its of b and update that
Dialogue: 0,0:57:00.96,0:57:08.20,Chinese,,0,0,0,,类似地，一个线程将获取其b的副本并更新它
Dialogue: 0,0:57:09.68,0:57:13.98,English,,0,0,0,,And now if I do my two print statements
Dialogue: 0,0:57:09.68,0:57:13.98,Chinese,,0,0,0,,现在，如果我做两个打印陈述
Dialogue: 0,0:57:14.54,0:57:18.02,English,,0,0,0,,If thread two picks up the value from the memory
Dialogue: 0,0:57:14.54,0:57:18.02,Chinese,,0,0,0,,如果线程2从内存中获取值
Dialogue: 0,0:57:18.54,0:57:24.10,English,,0,0,0,,Not knowing that thread one as a modified copy of that value  then it would naturally print one
Dialogue: 0,0:57:18.54,0:57:24.10,Chinese,,0,0,0,,不知道线程1作为该值的修改副本然后它会自然地打印一个
Dialogue: 0,0:57:24.96,0:57:30.44,English,,0,0,0,,And similarly if thread one picked up a copy of b from main memory it would print 100
Dialogue: 0,0:57:24.96,0:57:30.44,Chinese,,0,0,0,,并且类似地，如果线程1从主存储器中拾取了b的副本，则它将打印100
Dialogue: 0,0:57:30.54,0:57:36.90,English,,0,0,0,,So we'd see exactly this unallowable execution and the reason is
Dialogue: 0,0:57:30.54,0:57:36.90,Chinese,,0,0,0,,所以我们确实看到了这种不允许的执行，原因是
Dialogue: 0,0:57:37.48,0:57:42.36,English,,0,0,0,,Because each of these threads have their own private copies of these variables
Dialogue: 0,0:57:37.48,0:57:42.36,Chinese,,0,0,0,,因为这些线程中的每一个都有自己的这些变量的私有副本
Dialogue: 0,0:57:42.84,0:57:45.40,English,,0,0,0,,And they're not properly synchronized
Dialogue: 0,0:57:42.84,0:57:45.40,Chinese,,0,0,0,,而且它们没有正确同步
Dialogue: 0,0:57:46.18,0:57:50.90,English,,0,0,0,,But you could see in a hardware scenario it would be easy to build this hardware and make that mistake
Dialogue: 0,0:57:46.18,0:57:50.90,Chinese,,0,0,0,,但是你可以在硬件场景中看到构建这个硬件并犯这个错误很容易
Dialogue: 0,0:57:52.30,0:57:55.92,English,,0,0,0,,So how does it work in a multi-core processor well
Dialogue: 0,0:57:52.30,0:57:55.92,Chinese,,0,0,0,,那么它如何在多核处理器中很好地工作呢
Dialogue: 0,0:57:56.46,0:57:59.26,English,,0,0,0,,They have a trick they call it snoopy caches
Dialogue: 0,0:57:56.46,0:57:59.26,Chinese,,0,0,0,,他们有一个技巧，他们称之为史努比缓存
Dialogue: 0,0:58:00.34,0:58:05.72,English,,0,0,0,,And it's a little bit like the readers writers of synchronization that
Dialogue: 0,0:58:00.34,0:58:05.72,Chinese,,0,0,0,,它有点像同步的读者编写者那样
Dialogue: 0,0:58:05.72,0:58:07.94,English,,0,0,0,,You're working on for your proxies
Dialogue: 0,0:58:05.72,0:58:07.94,Chinese,,0,0,0,,你正在为你的代理工作
Dialogue: 0,0:58:08.56,0:58:13.28,English,,0,0,0,,That you want to make it so that if everyone's just reading some shared value
Dialogue: 0,0:58:08.56,0:58:13.28,Chinese,,0,0,0,,如果每个人都只是阅读一些共享价值，那么你想做到这一点
Dialogue: 0,0:58:13.64,0:58:19.44,English,,0,0,0,,They should be able to get copies into their own caches  to optimize the performance of it
Dialogue: 0,0:58:13.64,0:58:19.44,Chinese,,0,0,0,,他们应该能够将副本复制到自己的缓存中以优化其性能
Dialogue: 0,0:58:20.26,0:58:24.96,English,,0,0,0,,But if one of them wants to write to it,it needs to get an exclusive copy of it
Dialogue: 0,0:58:20.26,0:58:24.96,Chinese,,0,0,0,,但如果其中一个人想要写它，它需要获得它的独家副本
Dialogue: 0,0:58:25.62,0:58:27.58,English,,0,0,0,,And lock out any other thread
Dialogue: 0,0:58:25.62,0:58:27.58,Chinese,,0,0,0,,并锁定任何其他线程
Dialogue: 0,0:58:28.06,0:58:35.46,English,,0,0,0,,From accessing that either to read it or to write it from long enough to make the update
Dialogue: 0,0:58:28.06,0:58:35.46,Chinese,,0,0,0,,从访问它来读取它或写入足够长的时间来进行更新
Dialogue: 0,0:58:36.42,0:58:37.56,English,,0,0,0,,And so
Dialogue: 0,0:58:36.42,0:58:37.56,Chinese,,0,0,0,,所以
Dialogue: 0,0:58:40.12,0:58:48.16,English,,0,0,0,,They have a protocol where they tag actually and these tags are at the level of cache lines typically
Dialogue: 0,0:58:40.12,0:58:48.16,Chinese,,0,0,0,,他们有一个实际标记的协议，这些标记通常位于缓存行的级别
Dialogue: 0,0:58:48.78,0:58:55.28,English,,0,0,0,,So the tagged cache line in main memory with its state and the typical state would be invalid
Dialogue: 0,0:58:48.78,0:58:55.28,Chinese,,0,0,0,,因此，主存储器中标记的高速缓存行及其状态和典型状态将是无效的
Dialogue: 0,0:58:56.12,0:58:59.52,English,,0,0,0,,It's shared oryx its exclusive
Dialogue: 0,0:58:56.12,0:58:59.52,Chinese,,0,0,0,,它是独家的oryx
Dialogue: 0,0:59:00.14,0:59:06.74,English,,0,0,0,,So shared means that there can be a copies of it but they can only be read-only copies
Dialogue: 0,0:59:00.14,0:59:06.74,Chinese,,0,0,0,,所以共享意味着可以有它的副本，但它们只能是只读副本
Dialogue: 0,0:59:07.34,0:59:14.08,English,,0,0,0,,And exclusive meaning that it's exclusively available to a single thread
Dialogue: 0,0:59:07.34,0:59:14.08,Chinese,,0,0,0,,并且排他性意味着它仅供单个线程使用
Dialogue: 0,0:59:15.84,0:59:19.36,English,,0,0,0,,So this is built into them the hardware of a multi-core processor
Dialogue: 0,0:59:15.84,0:59:19.36,Chinese,,0,0,0,,因此，它内置于多核处理器的硬件中
Dialogue: 0,0:59:20.10,0:59:30.18,English,,0,0,0,,So what will happen that is in order to do a write to a thread one will acquire an exclusive copy of this element
Dialogue: 0,0:59:20.10,0:59:30.18,Chinese,,0,0,0,,那么为了对线程进行写操作会发生什么，将获得该元素的独占副本
Dialogue: 0,0:59:30.18,0:59:34.88,English,,0,0,0,,And that actually tagging happens down here at the main memory and in the cache both
Dialogue: 0,0:59:30.18,0:59:34.88,Chinese,,0,0,0,,实际上，标记发生在主存储器和缓存中
Dialogue: 0,0:59:37.86,0:59:44.22,English,,0,0,0,,Oh and similarly if thread two wants a to write to b
Dialogue: 0,0:59:37.86,0:59:44.22,Chinese,,0,0,0,,哦，类似的，如果线程2想要写入b
Dialogue: 0,0:59:44.52,0:59:46.72,English,,0,0,0,,It must get an exclusive copy of that
Dialogue: 0,0:59:44.52,0:59:46.72,Chinese,,0,0,0,,它必须得到它的独家副本
Dialogue: 0,0:59:48.44,0:59:52.88,English,,0,0,0,,And then when the read occurs what happens is actually this cache
Dialogue: 0,0:59:48.44,0:59:52.88,Chinese,,0,0,0,,然后当读取发生时，实际发生的是这个缓存
Dialogue: 0,0:59:53.96,0:59:59.60,English,,0,0,0,,Miss will send out a signal on a bus a shared communication medium saying
Dialogue: 0,0:59:53.96,0:59:59.60,Chinese,,0,0,0,,小姐将在公共汽车上发出一个共享通信媒体的信号
Dialogue: 0,1:00:00.10,1:00:01.34,English,,0,0,0,,I want to read a
Dialogue: 0,1:00:00.10,1:00:01.34,Chinese,,0,0,0,,我想读一个
Dialogue: 0,1:00:02.50,1:00:06.32,English,,0,0,0,,And instead of the main memory responding to it actually it will
Dialogue: 0,1:00:02.50,1:00:06.32,Chinese,,0,0,0,,而不是主内存响应它实际上它会
Dialogue: 0,1:00:07.84,1:00:11.54,English,,0,0,0,,That result will be supplied by the other cache
Dialogue: 0,1:00:07.84,1:00:11.54,Chinese,,0,0,0,,该结果将由其他缓存提供
Dialogue: 0,1:00:12.42,1:00:16.54,English,,0,0,0,,And it will convert the state of this element to being a shared element
Dialogue: 0,1:00:12.42,1:00:16.54,Chinese,,0,0,0,,它会将此元素的状态转换为共享元素
Dialogue: 0,1:00:18.74,1:00:23.20,English,,0,0,0,,Locally but you'll see that the main memory element isn't updated yet it
Dialogue: 0,1:00:18.74,1:00:23.20,Chinese,,0,0,0,,在本地但你会看到主存储器元素尚未更新
Dialogue: 0,1:00:23.20,1:00:26.30,English,,0,0,0,,Goes through the whole right-back protocol you've already seen
Dialogue: 0,1:00:23.20,1:00:26.30,Chinese,,0,0,0,,完成你已经看过的整个右后卫协议
Dialogue: 0,1:00:26.82,1:00:29.50,English,,0,0,0,,And sometimes it will update that there's different implementations
Dialogue: 0,1:00:26.82,1:00:29.50,Chinese,,0,0,0,,有时它会更新有不同的实现
Dialogue: 0,1:00:30.16,1:00:31.88,English,,0,0,0,,But this is why it's called a snoopy cache is
Dialogue: 0,1:00:30.16,1:00:31.88,Chinese,,0,0,0,,但这就是它被称为snoopy缓存的原因
Dialogue: 0,1:00:32.04,1:00:38.76,English,,0,0,0,,That it basically thread two is peeking into or getting it access to information
Dialogue: 0,1:00:32.04,1:00:38.76,Chinese,,0,0,0,,它基本上是线程二是窥视或获取信息
Dialogue: 0,1:00:38.82,1:00:40.70,English,,0,0,0,,That's available in thread ones cache
Dialogue: 0,1:00:38.82,1:00:40.70,Chinese,,0,0,0,,这在线程缓存中可用
Dialogue: 0,1:00:43.10,1:00:48.96,English,,0,0,0,,And so now thread two will correctly get a copy of a
Dialogue: 0,1:00:43.10,1:00:48.96,Chinese,,0,0,0,,所以现在线程二将正确获得一个副本
Dialogue: 0,1:00:49.46,1:00:50.98,English,,0,0,0,,That's in this shared state
Dialogue: 0,1:00:49.46,1:00:50.98,Chinese,,0,0,0,,那是在这个共享状态
Dialogue: 0,1:00:51.62,1:00:57.30,English,,0,0,0,,And the same goes would be it will snoop over and thread two will one will get a readable copy
Dialogue: 0,1:00:51.62,1:00:57.30,Chinese,,0,0,0,,同样的情况是它会窥探而线程二将会得到一个可读的副本
Dialogue: 0,1:00:57.88,1:00:59.92,English,,0,0,0,,These are now all marked as shared state
Dialogue: 0,1:00:57.88,1:00:59.92,Chinese,,0,0,0,,现在这些都标记为共享状态
Dialogue: 0,1:01:00.52,1:01:04.68,English,,0,0,0,,And so if either of them want to write
Dialogue: 0,1:01:00.52,1:01:04.68,Chinese,,0,0,0,,所以如果他们中的任何一个想写
Dialogue: 0,1:01:04.68,1:01:08.74,English,,0,0,0,,They'd have to now basically get exclusive access to it
Dialogue: 0,1:01:04.68,1:01:08.74,Chinese,,0,0,0,,他们现在必须基本上获得独家访问权限
Dialogue: 0,1:01:09.06,1:01:11.10,English,,0,0,0,,And that would have to then disable
Dialogue: 0,1:01:09.06,1:01:11.10,Chinese,,0,0,0,,那将不得不禁用
Dialogue: 0,1:01:11.82,1:01:16.04,English,,0,0,0,,The copy and the other in the other location
Dialogue: 0,1:01:11.82,1:01:16.04,Chinese,,0,0,0,,副本和另一个位置的副本
Dialogue: 0,1:01:16.16,1:01:20.48,English,,0,0,0,,So you can imagine this protocol being non-trivial actually to get right and to implement
Dialogue: 0,1:01:16.16,1:01:20.48,Chinese,,0,0,0,,所以你可以想象这个协议实际上是非常重要的，以实现正确和实现
Dialogue: 0,1:01:20.90,1:01:24.80,English,,0,0,0,,And it gets way more complicated than this with all the variations on it
Dialogue: 0,1:01:20.90,1:01:24.80,Chinese,,0,0,0,,它的变化比这更复杂，并且有各种变化
Dialogue: 0,1:01:26.10,1:01:31.10,English,,0,0,0,,So but it's become the norm in multi-core hardware design
Dialogue: 0,1:01:26.10,1:01:31.10,Chinese,,0,0,0,,因此，它已成为多核硬件设计的常态
Dialogue: 0,1:01:31.86,1:01:36.36,English,,0,0,0,,But it's actually part of the factor that limits the core count on a processor
Dialogue: 0,1:01:31.86,1:01:36.36,Chinese,,0,0,0,,但它实际上是限制处理器核心数量的因素之一
Dialogue: 0,1:01:37.08,1:01:43.32,English,,0,0,0,,Because just the hardware involved in keeping the consistency across the caches is non-trivial
Dialogue: 0,1:01:37.08,1:01:43.32,Chinese,,0,0,0,,因为保持高速缓存之间一致性所涉及的硬件并非易事
Dialogue: 0,1:01:43.32,1:01:49.12,English,,0,0,0,,It has to work very fast we're talking at the cash rate access speeds
Dialogue: 0,1:01:43.32,1:01:49.12,Chinese,,0,0,0,,它必须以非常快的速度工作，我们以现金利率访问速度进行讨论
Dialogue: 0,1:01:49.88,1:01:52.30,English,,0,0,0,,So there's not a lot of time involved in there
Dialogue: 0,1:01:49.88,1:01:52.30,Chinese,,0,0,0,,所以那里没有太多时间
Dialogue: 0,1:01:52.42,1:01:54.96,English,,0,0,0,,So actually implementing this stuff making it run
Dialogue: 0,1:01:52.42,1:01:54.96,Chinese,,0,0,0,,所以实际上实现这个东西让它运行
Dialogue: 0,1:01:55.42,1:02:01.70,English,,0,0,0,,Making it scale across say 8 cores,10 cores,16 cores is not a not a trivial thing
Dialogue: 0,1:01:55.42,1:02:01.70,Chinese,,0,0,0,,将其扩展为8核，10核，16核并不是一件轻而易举的事
Dialogue: 0,1:02:02.20,1:02:07.72,English,,0,0,0,,But that that goes on in the background and so you can for most systems nowadays you can assume that
Dialogue: 0,1:02:02.20,1:02:07.72,Chinese,,0,0,0,,但是这种情况在后台发生，所以你现在可以为大多数系统假设
Dialogue: 0,1:02:09.88,1:02:15.84,English,,0,0,0,,There's some memory consistency model that you can program to that's supported by the hardware of the system
Dialogue: 0,1:02:09.88,1:02:15.84,Chinese,,0,0,0,,有一些内存一致性模型，你可以编程到系统硬件支持的模型
Dialogue: 0,1:02:17.30,1:02:24.22,English,,0,0,0,,And that this serial serializability that's referred to as sort of the easiest to understand
Dialogue: 0,1:02:17.30,1:02:24.22,Chinese,,0,0,0,,并且这种串行可串行性被称为最容易理解的类型
Dialogue: 0,1:02:24.34,1:02:26.28,English,,0,0,0,,There's others at a little bit more nuanced
Dialogue: 0,1:02:24.34,1:02:26.28,Chinese,,0,0,0,,还有其他一些细微差别
Dialogue: 0,1:02:29.04,1:02:33.40,English,,0,0,0,,Well guess that fell off the bottom here and doesn't seem right
Dialogue: 0,1:02:29.04,1:02:33.40,Chinese,,0,0,0,,好吧，猜测从这里跌落到底部并且似乎不对
Dialogue: 0,1:02:42.30,1:02:42.98,English,,0,0,0,,That's it
Dialogue: 0,1:02:42.30,1:02:42.98,Chinese,,0,0,0,,而已
Dialogue: 0,1:02:43.88,1:02:46.80,English,,0,0,0,,Okay so just to wrap that up then
Dialogue: 0,1:02:43.88,1:02:46.80,Chinese,,0,0,0,,好的，那就是把它包起来
Dialogue: 0,1:02:48.56,1:02:50.82,English,,0,0,0,,It gives you a flavor of and
Dialogue: 0,1:02:48.56,1:02:50.82,Chinese,,0,0,0,,它给你一种风味和
Dialogue: 0,1:02:52.10,1:02:57.62,English,,0,0,0,,You can see that getting programs to run fast through multi-threading is not easy
Dialogue: 0,1:02:52.10,1:02:57.62,Chinese,,0,0,0,,你可以看到让程序快速通过多线程运行并不容易
Dialogue: 0,1:02:58.16,1:03:02.98,English,,0,0,0,,You often have to rewrite your application you have to think about the algorithm you have to worry about debugging
Dialogue: 0,1:02:58.16,1:03:02.98,Chinese,,0,0,0,,你经常需要重写你的应用程序，你必须考虑你必须担心调试的算法
Dialogue: 0,1:03:03.52,1:03:06.52,English,,0,0,0,,It as you've already discovered at both the
Dialogue: 0,1:03:03.52,1:03:06.52,Chinese,,0,0,0,,就像你已经在这两个地方发现的一样
Dialogue: 0,1:03:07.28,1:03:12.28,English,,0,0,0,,The shell web and the proxy lab that concurrency where you can't predict the order of events
Dialogue: 0,1:03:07.28,1:03:12.28,Chinese,,0,0,0,,shell web和代理实验室，即并发性，你无法预测事件的顺序
Dialogue: 0,1:03:12.88,1:03:16.30,English,,0,0,0,,Makes it much more difficult to debug code
Dialogue: 0,1:03:12.88,1:03:16.30,Chinese,,0,0,0,,调试代码变得更加困难
Dialogue: 0,1:03:16.80,1:03:18.62,English,,0,0,0,,So all these factors come in
Dialogue: 0,1:03:16.80,1:03:18.62,Chinese,,0,0,0,,因此所有这些因素都会出现
Dialogue: 0,1:03:20.18,1:03:24.30,English,,0,0,0,,And you have to have some understanding of the underlying mechanisms that are used
Dialogue: 0,1:03:20.18,1:03:24.30,Chinese,,0,0,0,,你必须对所使用的基础机制有所了解
Dialogue: 0,1:03:24.98,1:03:27.02,English,,0,0,0,,And what their performance implications are
Dialogue: 0,1:03:24.98,1:03:27.02,Chinese,,0,0,0,,它们的性能影响是什么
Dialogue: 0,1:03:27.66,1:03:30.12,English,,0,0,0,,So in particular let me just observe here that
Dialogue: 0,1:03:27.66,1:03:30.12,Chinese,,0,0,0,,所以特别让我在这里观察一下
Dialogue: 0,1:03:32.58,1:03:34.98,English,,0,0,0,,If I'm like doing synchronization
Dialogue: 0,1:03:32.58,1:03:34.98,Chinese,,0,0,0,,如果我喜欢做同步
Dialogue: 0,1:03:37.36,1:03:43.06,English,,0,0,0,,Across threads like you saw that original one where they are fighting over this global variable
Dialogue: 0,1:03:37.36,1:03:43.06,Chinese,,0,0,0,,像你看过原始的那个线程，他们正在争夺这个全局变量
Dialogue: 0,1:03:43.58,1:03:44.98,English,,0,0,0,, psum whatever it was called
Dialogue: 0,1:03:43.58,1:03:44.98,Chinese,,0,0,0,,psum无论它叫什么
Dialogue: 0,1:03:46.12,1:03:48.24,English,,0,0,0,,You can imagine these the caches
Dialogue: 0,1:03:46.12,1:03:48.24,Chinese,,0,0,0,,你可以想象这些缓存
Dialogue: 0,1:03:48.66,1:03:57.48,English,,0,0,0,,In this battle with each other to try and get exclusive access to this single memory of value
Dialogue: 0,1:03:48.66,1:03:57.48,Chinese,,0,0,0,,在这场与对方的战斗中，尝试并获得对这一单一记忆价值的独占访问权
Dialogue: 0,1:03:58.34,1:04:04.04,English,,0,0,0,,And because each one is running as fast as it possibly can
Dialogue: 0,1:03:58.34,1:04:04.04,Chinese,,0,0,0,,因为每个人都尽可能快地跑
Dialogue: 0,1:04:04.20,1:04:11.20,English,,0,0,0,,But each one requires getting exclusive copy writing to it and releasing it
Dialogue: 0,1:04:04.20,1:04:11.20,Chinese,,0,0,0,,但是每个人都需要获得独家的复制写作并发布它
Dialogue: 0,1:04:11.32,1:04:15.98,English,,0,0,0,,So that locking mechanism is flying back and forth between these caches
Dialogue: 0,1:04:11.32,1:04:15.98,Chinese,,0,0,0,,因此锁定机制在这些缓存之间来回飞行
Dialogue: 0,1:04:16.68,1:04:18.72,English,,0,0,0,,And it's really not very fast so
Dialogue: 0,1:04:16.68,1:04:18.72,Chinese,,0,0,0,,它真的不是很快
Dialogue: 0,1:04:19.16,1:04:22.52,English,,0,0,0,,That's the kind of thing is why
Dialogue: 0,1:04:19.16,1:04:22.52,Chinese,,0,0,0,,这就是为什么
Dialogue: 0,1:04:24.02,1:04:29.18,English,,0,0,0,,And also you know as an application programmer you're making calls 
Dialogue: 0,1:04:24.02,1:04:29.18,Chinese,,0,0,0,,而且你知道作为应用程序员你正在打电话
Dialogue: 0,1:04:30.18,1:04:35.50,English,,0,0,0,,Semaphore call bounces you up into the OS kernel which is a cost involved
Dialogue: 0,1:04:30.18,1:04:35.50,Chinese,,0,0,0,,信号量调用会将你反弹到操作系统内核中，这是一个成本问题
Dialogue: 0,1:04:36.20,1:04:43.04,English,,0,0,0,,So this thing has all the bad all the things that make programs not run the way you really like them to
Dialogue: 0,1:04:36.20,1:04:43.04,Chinese,,0,0,0,,因此，所有使程序无法按照你真正喜欢的方式运行的事情都会变得非常糟糕
Dialogue: 0,1:04:43.52,1:04:48.48,English,,0,0,0,,So that's one of the challenges in parallel programming is how do you actually
Dialogue: 0,1:04:43.52,1:04:48.48,Chinese,,0,0,0,,因此，并行编程的挑战之一就是你如何实际
Dialogue: 0,1:04:49.16,1:04:51.52,English,,0,0,0,,Make use of the parallelism that's there
Dialogue: 0,1:04:49.16,1:04:51.52,Chinese,,0,0,0,,利用那里的并行性
Dialogue: 0,1:04:51.78,1:04:57.24,English,,0,0,0,,Without getting bogged down by the cost of the various mechanisms of control
Dialogue: 0,1:04:51.78,1:04:57.24,Chinese,,0,0,0,,不会因各种控制机制的成本而陷入困境
Dialogue: 0,1:04:58.86,1:05:03.54,English,,0,0,0,,Oh so anyways this is part of what you have to appreciate and understand as a programmer
Dialogue: 0,1:04:58.86,1:05:03.54,Chinese,,0,0,0,,哦，不管怎样，这是你作为程序员必须欣赏和理解的一部分
Dialogue: 0,1:05:04.00,1:05:08.56,English,,0,0,0,,Is how these things work at a level deep enough that you'll have some sense of 
Dialogue: 0,1:05:04.00,1:05:08.56,Chinese,,0,0,0,,这些东西是如何工作在足够深的水平，你会有一些感觉
Dialogue: 0,1:05:08.56,1:05:13.28,English,,0,0,0,,What makes programs run faster or slower where the mistakes could want
Dialogue: 0,1:05:08.56,1:05:13.28,Chinese,,0,0,0,,是什么让程序在错误可能需要的地方运行得更快或更慢
Dialogue: 0,1:05:14.98,1:05:18.62,English,,0,0,0,,So that's just a little flavor of a much bigger topic
Dialogue: 0,1:05:14.98,1:05:18.62,Chinese,,0,0,0,,所以这只是一个更大的话题的一点点味道
Dialogue: 0,1:05:19.48,1:05:20.48,English,,0,0,0,,So that's it for today
Dialogue: 0,1:05:19.48,1:05:20.48,Chinese,,0,0,0,,这就是今天的情况
